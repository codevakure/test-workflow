name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { context, github } = require('@actions/github');
            
            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              await github.rest.pulls.createReviewComment({
                ...context.repo,
                pull_number: context.payload.pull_request.number,
                commit_id: file.sha,
                path: file.filename,
                body: `${priorityEmoji[priority]}**${category}**\n\n${message}`,
                line: line
              });
            }

            async function checkFileContent(file, content, lines, fileExt) {
              // Security Checks
              if (content.includes('innerHTML') || content.includes('bypassSecurityTrust')) {
                await createComment(file,
                  lines.findIndex(line => line.includes('innerHTML')) + 1,
                  'critical',
                  'Security Risk',
                  'Potential XSS vulnerability detected. Use Angular\'s built-in sanitization.'
                );
              }

              // TypeScript Specific Checks
              if (fileExt === 'ts') {
                await checkTypeScriptFile(file, content, lines);
              }

              // HTML Specific Checks
              if (fileExt === 'html') {
                await checkHtmlFile(file, content, lines);
              }

              // Style Specific Checks
              if (fileExt === 'scss' || fileExt === 'css') {
                await checkStyleFile(file, content, lines);
              }
            }

            async function checkTypeScriptFile(file, content, lines) {
              // Observable Memory Leak Checks
              const subscriptions = content.match(/subscribe\s*\(/g);
              const hasUnsubscribe = content.includes('unsubscribe()') || 
                                   content.includes('takeUntil') ||
                                   content.includes('| async');
              
              if (subscriptions && !hasUnsubscribe) {
                await createComment(file,
                  lines.findIndex(line => line.includes('subscribe')) + 1,
                  'critical',
                  'Memory Leak Risk',
                  'Subscription not properly managed. Use one of these patterns:\n\n' +
                  '```typescript\n' +
                  '// Option 1: Using takeUntil\n' +
                  'private destroy$ = new Subject<void>();\n\n' +
                  'ngOnInit() {\n' +
                  '  this.someObservable$.pipe(\n' +
                  '    takeUntil(this.destroy$)\n' +
                  '  ).subscribe(data => ...);\n' +
                  '}\n\n' +
                  'ngOnDestroy() {\n' +
                  '  this.destroy$.next();\n' +
                  '  this.destroy$.complete();\n' +
                  '}\n\n' +
                  '// Option 2: Using async pipe in template\n' +
                  '{{ data$ | async }}\n\n' +
                  '// Option 3: Manual unsubscription\n' +
                  'private subscription: Subscription;\n\n' +
                  'ngOnInit() {\n' +
                  '  this.subscription = this.data$.subscribe(...);\n' +
                  '}\n\n' +
                  'ngOnDestroy() {\n' +
                  '  this.subscription?.unsubscribe();\n' +
                  '}\n' +
                  '```'
                );
              }

              // Enum Check for Repeated Strings
              const templateStrings = content.match(/(['"])[^'"]*\1/g) || [];
              const stringOccurrences = {};
              
              templateStrings.forEach(str => {
                const cleanStr = str.replace(/['"]/g, '');
                stringOccurrences[cleanStr] = (stringOccurrences[cleanStr] || 0) + 1;
              });

              const repeatedStrings = Object.entries(stringOccurrences)
                .filter(([str, count]) => count > 2 && str.length > 2)
                .map(([str]) => str);

              if (repeatedStrings.length > 0) {
                await createComment(file,
                  1,
                  'recommended',
                  'Code Maintainability',
                  'Consider creating an enum for repeated string literals:\n\n' +
                  '```typescript\n' +
                  'export enum StatusTypes {\n' +
                  `  ${repeatedStrings[0].toUpperCase()} = '${repeatedStrings[0]}',\n` +
                  '  // Add other values\n' +
                  '}\n' +
                  '```'
                );
              }

              // Change Detection Check
              if (!content.includes('ChangeDetectionStrategy.OnPush')) {
                await createComment(file,
                  1,
                  'recommended',
                  'Performance Optimization',
                  'Consider using ChangeDetectionStrategy.OnPush for better performance.'
                );
              }
            }

            async function checkHtmlFile(file, content, lines) {
              // Performance Checks
              if (content.includes('*ngFor') && !content.includes('trackBy')) {
                await createComment(file,
                  lines.findIndex(line => line.includes('*ngFor')) + 1,
                  'critical',
                  'Performance',
                  'Add trackBy function to improve performance with *ngFor.'
                );
              }

              // Accessibility Checks
              const missingAccessibility = {
                img: /<img[^>]*(?!alt=)[^>]*>/g,
                button: /<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/g,
                input: /<input[^>]*(?!aria-label|id=)[^>]*>/g
              };

              Object.entries(missingAccessibility).forEach(async ([element, pattern]) => {
                const matches = content.match(pattern);
                if (matches) {
                  await createComment(file,
                    lines.findIndex(line => matches.some(m => line.includes(m))) + 1,
                    'critical',
                    'Accessibility',
                    `${element.toUpperCase()} elements must have proper accessibility attributes.`
                  );
                }
              });
            }

            async function checkStyleFile(file, content, lines) {
              const hardcodedColors = content.match(/#[0-9a-fA-F]{3,6}/g);
              if (hardcodedColors) {
                await createComment(file,
                  lines.findIndex(line => line.includes(hardcodedColors[0])) + 1,
                  'optional',
                  'Style Management',
                  'Consider using CSS variables for better maintainability.'
                );
              }
            }

            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.payload.pull_request.number,
            });

            for (const file of files) {
              const content = fs.readFileSync(file.filename, 'utf8');
              const lines = content.split('\n');
              const fileExt = file.filename.split('.').pop();
              
              await checkFileContent(file, content, lines, fileExt);
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.payload.pull_request.number,
            });

            async function verifyFix(file, comment) {
              const content = fs.readFileSync(file, 'utf8');
              
              // Verification rules for different types of issues
              const verificationRules = {
                'Security Risk': () => !content.includes('innerHTML') && !content.includes('bypassSecurityTrust'),
                'Performance': () => comment.body.includes('trackBy') ? content.includes('trackBy') : false,
                'Accessibility': () => {
                  if (comment.body.includes('IMG')) return !content.match(/<img[^>]*(?!alt=)[^>]*>/g);
                  if (comment.body.includes('BUTTON')) return !content.match(/<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/g);
                  if (comment.body.includes('INPUT')) return !content.match(/<input[^>]*(?!aria-label|id=)[^>]*>/g);
                  return false;
                },
                'Memory Leak Risk': () => content.includes('takeUntil') || 
                                       content.includes('| async') ||
                                       (content.includes('unsubscribe()') && content.includes('ngOnDestroy')),
                'Code Maintainability': () => content.includes('enum') || 
                                            content.match(/\w+\.\w+/g)?.some(ref => ref.split('.')[1].toUpperCase() === ref.split('.')[1]),
                'Performance Optimization': () => content.includes('ChangeDetectionStrategy.OnPush'),
                'Style Management': () => !content.match(/#[0-9a-fA-F]{3,6}/g)
              };

              // Find the category from the comment
              const category = Object.keys(verificationRules).find(key => comment.body.includes(key));
              return category ? verificationRules[category]() : false;
            }

            for (const comment of comments) {
              try {
                const isFixed = await verifyFix(comment.path, comment);
                
                if (isFixed) {
                  await github.rest.pulls.deleteReviewComment({
                    ...context.repo,
                    comment_id: comment.id
                  });
                  
                  await github.rest.pulls.createReviewComment({
                    ...context.repo,
                    pull_number: context.payload.pull_request.number,
                    commit_id: comment.commit_id,
                    path: comment.path,
                    line: comment.line,
                    body: 'âœ… Issue resolved automatically based on implemented changes.'
                  });
                }
              } catch (error) {
                console.error(`Error processing comment: ${error}`);
              }
            }
            
            const remainingCriticalIssues = comments.filter(async comment => 
              comment.body.includes('ðŸš¨ CRITICAL') && 
              !(await verifyFix(comment.path, comment))
            );

            if (remainingCriticalIssues.length > 0) {
              core.setFailed('Critical issues must be resolved before merging.');
            }