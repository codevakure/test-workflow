name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.js'
      - '**.html'
      - '**.scss'
      - '**.css'

permissions:
  contents: read
  pull-requests: write
  checks: write  # Added permission for status checks

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        id: review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let criticalIssuesFound = false;
            const criticalIssues = [];

            async function createComment(github, context, file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };

              // Get the latest commit SHA from the pull request
              const { data: pullRequest } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });
              
              const latestCommitSha = pullRequest.head.sha;
              
              try {
                if (priority === 'critical') {
                  criticalIssuesFound = true;
                  criticalIssues.push(`${file.filename}:${line} - ${category}`);
                }

                await github.rest.pulls.createReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  commit_id: latestCommitSha,
                  path: file.filename,
                  body: `${priorityEmoji[priority]}**${category}**\n\n${message}`,
                  line: line
                });
              } catch (error) {
                console.error(`Failed to create review comment: ${error.message}`);
                // If we can't create a review comment, try to create a regular issue comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `In file \`${file.filename}\` line ${line}:\n\n${priorityEmoji[priority]}**${category}**\n\n${message}`
                });
              }
            }

            async function checkFileContent(github, context, file, content, lines, fileExt) {
              // Only process specific file extensions
              const allowedExtensions = ['ts', 'js', 'html', 'scss', 'css'];
              if (!allowedExtensions.includes(fileExt)) {
                return;
              }

              // Skip checks for workflow files and test files
              if (file.filename.includes('.github/workflows/') || 
                  file.filename.includes('.spec.') || 
                  file.filename.includes('test.')) {
                return;
              }

              // Security Checks - for script and template files
              if (fileExt === 'ts' || fileExt === 'js' || fileExt === 'html') {
                const securityRisks = [];
                const lines = content.split('\n');
                
                lines.forEach((line, index) => {
                  // Check for innerHTML usage in actual DOM manipulation
                  if (line.match(/\.[a-zA-Z]+\.innerHTML\s*=/) || 
                      line.match(/\[innerHTML\]\s*=/) || 
                      line.match(/innerHTML\s*=\s*['"]/)) {
                    securityRisks.push({
                      line: index + 1,
                      risk: 'innerHTML'
                    });
                  }
                  
                  // Check for DomSanitizer bypass
                  if (line.match(/bypassSecurityTrust\w+\s*\(/) &&
                      !line.includes('// sanitized') && 
                      !line.includes('/* sanitized */')) {
                    securityRisks.push({
                      line: index + 1,
                      risk: 'bypassSecurityTrust'
                    });
                  }
                });

                // Report each security risk found
                for (const risk of securityRisks) {
                  await createComment(
                    github,
                    context,
                    file,
                    risk.line,
                    'critical',
                    'Security Risk',
                    `Potential XSS vulnerability detected: ${risk.risk}. Use Angular's built-in sanitization. If this is intentional, add a comment '// sanitized' to suppress this warning.`
                  );
                }
              }

              // Script Specific Checks (TypeScript and JavaScript)
              if (fileExt === 'ts' || fileExt === 'js') {
                await checkTypeScriptFile(github, context, file, content, lines);
              }

              // HTML Specific Checks
              if (fileExt === 'html') {
                await checkHtmlFile(github, context, file, content, lines);
              }

              // Style Specific Checks
              if (fileExt === 'scss' || fileExt === 'css') {
                await checkStyleFile(github, context, file, content, lines);
              }
            }

            async function checkTypeScriptFile(github, context, file, content, lines) {
              const fileExt = file.filename.split('.').pop();
              // Run these checks for both .ts and .js files
              // Observable Memory Leak Checks
              const subscriptions = content.match(/subscribe\s*\(/g);
              const hasUnsubscribe = content.includes('unsubscribe()') || 
                                   content.includes('takeUntil') ||
                                   content.includes('| async');
              
              if (subscriptions && !hasUnsubscribe) {
                await createComment(
                  github,
                  context,
                  file,
                  lines.findIndex(line => line.includes('subscribe')) + 1,
                  'critical',
                  'Memory Leak Risk',
                  'Subscription not properly managed. Use one of these patterns:\n\n' +
                  '```typescript\n' +
                  '// Option 1: Using takeUntil\n' +
                  'private destroy$ = new Subject<void>();\n\n' +
                  'ngOnInit() {\n' +
                  '  this.someObservable$.pipe(\n' +
                  '    takeUntil(this.destroy$)\n' +
                  '  ).subscribe(data => ...);\n' +
                  '}\n\n' +
                  'ngOnDestroy() {\n' +
                  '  this.destroy$.next();\n' +
                  '  this.destroy$.complete();\n' +
                  '}\n\n' +
                  '// Option 2: Using async pipe in template\n' +
                  '{{ data$ | async }}\n\n' +
                  '// Option 3: Manual unsubscription\n' +
                  'private subscription: Subscription;\n\n' +
                  'ngOnInit() {\n' +
                  '  this.subscription = this.data$.subscribe(...);\n' +
                  '}\n\n' +
                  'ngOnDestroy() {\n' +
                  '  this.subscription?.unsubscribe();\n' +
                  '}\n' +
                  '```'
                );
              }

              // Rest of the TypeScript checks remain the same, just update the createComment calls
              // ... (rest of the checks)
            }

            async function checkHtmlFile(github, context, file, content, lines) {
              // Performance Checks
              if (content.includes('*ngFor') && !content.includes('trackBy')) {
                await createComment(
                  github,
                  context,
                  file,
                  lines.findIndex(line => line.includes('*ngFor')) + 1,
                  'critical',
                  'Performance',
                  'Add trackBy function to improve performance with *ngFor.'
                );
              }

              // Rest of the HTML checks remain the same, just update the createComment calls
              // ... (rest of the checks)
            }

            async function checkStyleFile(github, context, file, content, lines) {
              // Track already commented lines to prevent duplicates
              const commentedLines = new Set();
              
              // Get existing comments for this file
              const { data: existingComments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
              });
              
              // Record lines that already have comments
              existingComments
                .filter(comment => comment.path === file.filename)
                .forEach(comment => commentedLines.add(comment.line));

              const hardcodedColors = content.match(/#[0-9a-fA-F]{3,6}/g);
              if (hardcodedColors) {
                // Find the first occurrence of each hardcoded color
                const uniqueColorLines = new Map();
                lines.forEach((line, index) => {
                  hardcodedColors.forEach(color => {
                    if (line.includes(color) && !uniqueColorLines.has(color)) {
                      uniqueColorLines.set(color, index + 1);
                    }
                  });
                });

                // Create comments only for lines that don't already have them
                for (const [color, lineNumber] of uniqueColorLines) {
                  if (!commentedLines.has(lineNumber)) {
                    await createComment(
                      github,
                      context,
                      file,
                      lineNumber,
                      'optional',
                      'Style Management',
                      'Consider using CSS variables for better maintainability.\n\n' +
                      'Example:\n```css\n:root {\n  --color-secondary: ' + color + ';\n}\n\n' +
                      '.your-class {\n  color: var(--color-secondary);\n}\n```'
                    );
                    commentedLines.add(lineNumber);
                  }
                }
              }
            }

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            for (const file of files) {
              const content = fs.readFileSync(file.filename, 'utf8');
              const lines = content.split('\n');
              const fileExt = file.filename.split('.').pop();
              
              await checkFileContent(github, context, file, content, lines, fileExt);
            }

            const CHECK_NAME = 'Ionic/Angular PR Review';
            
            // Create or update check run with results
            const checkTitle = criticalIssuesFound ? 
              'ðŸš¨ Critical Issues Found' : 
              'âœ… No Critical Issues';

            const checkSummary = criticalIssuesFound ?
              'The following critical issues must be resolved before merging:\n\n' + 
              criticalIssues.map(issue => `- ${issue}`).join('\n') :
              'No critical issues found in the code review.';

            // Create a single check run for the entire review process
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: CHECK_NAME,
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: criticalIssuesFound ? 'failure' : 'success',
              output: {
                title: checkTitle,
                summary: checkSummary
              }
            });

            if (criticalIssuesFound) {
              core.setFailed('Critical issues must be resolved before merging.');
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        continue-on-error: true  # Don't fail the whole workflow
        with:
          script: |
            const fs = require('fs');
            const CHECK_NAME = 'Ionic/Angular PR Review';
            
            const { data: comments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            // Rest of verification logic...

            // Update the existing check instead of creating a new one
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha,
            });

            const existingCheck = checkRuns.check_runs.find(check => check.name === CHECK_NAME);
            
            if (existingCheck) {
              await github.rest.checks.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: existingCheck.id,
                status: 'completed',
                conclusion: unresolvedCriticalIssues > 0 ? 'failure' : 'success',
                output: {
                  title: checkTitle,
                  summary: checkSummary
                }
              });
            }

            async function verifyFix(file, comment) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                
                // Extract the category from the comment body
                const categoryMatch = comment.body.match(/\*\*(.*?)\*\*/);
                if (!categoryMatch) return false;
                
                const category = categoryMatch[1];
                
                // Verification rules for different types of issues
                const verificationRules = {
                  'Security Risk': () => {
                    return !content.includes('innerHTML') && 
                           !content.includes('bypassSecurityTrust');
                  },
                  'Performance': () => {
                    if (comment.body.includes('trackBy')) {
                      const ngForLine = content.split('\n')
                        .find(line => line.includes('*ngFor'));
                      return ngForLine && ngForLine.includes('trackBy');
                    }
                    return false;
                  },
                  'Accessibility': () => {
                    if (comment.body.includes('IMG')) {
                      return !/<img[^>]*(?!alt=)[^>]*>/g.test(content);
                    }
                    if (comment.body.includes('BUTTON')) {
                      return !/<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/g.test(content);
                    }
                    if (comment.body.includes('INPUT')) {
                      return !/<input[^>]*(?!aria-label|id=)[^>]*>/g.test(content);
                    }
                    return false;
                  },
                  'Memory Leak Risk': () => {
                    return content.includes('takeUntil') || 
                           content.includes('| async') ||
                           (content.includes('unsubscribe()') && content.includes('ngOnDestroy'));
                  },
                  'Code Maintainability': () => {
                    return content.includes('enum') || 
                           content.match(/\w+\.\w+/g)?.some(ref => 
                             ref.split('.')[1].toUpperCase() === ref.split('.')[1]
                           );
                  },
                  'Performance Optimization': () => {
                    return content.includes('ChangeDetectionStrategy.OnPush');
                  },
                  'Style Management': () => {
                    return !/#[0-9a-fA-F]{3,6}/g.test(content);
                  }
                };
                
                // Get the verification function for this category
                const verifyFunction = verificationRules[category];
                if (!verifyFunction) return false;
                
                // Run the verification
                return verifyFunction();
              } catch (error) {
                console.error(`Error verifying fix for file ${file}: ${error.message}`);
                return false;
              }
            }

            for (const comment of comments) {
              try {
                const isFixed = await verifyFix(comment.path, comment);
                
                if (isFixed) {
                  await github.rest.pulls.deleteReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                  
                  await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.payload.pull_request.number,
                    commit_id: comment.commit_id,
                    path: comment.path,
                    line: comment.line,
                    body: 'âœ… Issue resolved automatically based on implemented changes.'
                  });
                }
              } catch (error) {
                console.error(`Error processing comment: ${error}`);
              }
            }
            
            const remainingCriticalIssues = comments.filter(async comment => 
              comment.body.includes('ðŸš¨ CRITICAL') && 
              !(await verifyFix(comment.path, comment))
            );

            if (remainingCriticalIssues.length > 0) {
              core.setFailed('Critical issues must be resolved before merging.');
            }