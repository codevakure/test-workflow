name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'
      - '**.js'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get the latest commit SHA from the PR
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;
            
            // Store existing comments to prevent duplicates
            const existingComments = new Map();
            const { data: currentComments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });
            
            for (const comment of currentComments) {
              const key = `${comment.path}:${comment.line}:${comment.body}`;
              existingComments.set(key, comment);
            }

            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              const commentBody = `${priorityEmoji[priority]}**${category}**\n\n${message}`;
              const commentKey = `${file.filename}:${line}:${commentBody}`;
              
              // Check if comment already exists
              if (!existingComments.has(commentKey)) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: file.filename,
                  body: commentBody,
                  line: line
                });
              }
            }

            async function checkFileContent(file, content, lines, fileExt) {
              // Security Checks
              if (content.includes('innerHTML') || content.includes('bypassSecurityTrust')) {
                const lineNum = lines.findIndex(line => 
                  line.includes('innerHTML') || line.includes('bypassSecurityTrust')
                ) + 1;
                if (lineNum > 0) {
                  await createComment(file, lineNum, 'critical', 'Security Risk',
                    'Potential XSS vulnerability detected. Use Angular\'s built-in sanitization.'
                  );
                }
              }

              // File type specific checks
              const checksMap = {
                ts: checkTypeScriptFile,
                html: checkHtmlFile,
                scss: checkStyleFile,
                css: checkStyleFile
              };

              if (checksMap[fileExt]) {
                await checksMap[fileExt](file, content, lines);
              }
            }

            async function checkTypeScriptFile(file, content, lines) {
              // Angular Component Checks
              if (content.includes('@Component')) {
                // Check for ChangeDetectionStrategy
                if (!content.includes('ChangeDetectionStrategy.OnPush')) {
                  await createComment(file, 1, 'recommended', 'Performance Optimization',
                    'Consider using ChangeDetectionStrategy.OnPush for better performance:\n```typescript\nimport { ChangeDetectionStrategy } from \'@angular/core\';\n\n@Component({\n  // ...\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n```'
                  );
                }

                // Check for standalone components
                if (content.includes('standalone: false') || !content.includes('standalone:')) {
                  await createComment(file, 1, 'recommended', 'Modern Angular Practices',
                    'Consider using standalone components for better tree-shaking and modularity:\n```typescript\n@Component({\n  // ...\n  standalone: true,\n  imports: [CommonModule, IonicModule, ...]\n})\n```'
                  );
                }

                // Check for ViewEncapsulation
                if (!content.includes('ViewEncapsulation')) {
                  await createComment(file, 1, 'recommended', 'Component Configuration',
                    'Consider explicitly setting ViewEncapsulation for better style control:\n```typescript\nimport { ViewEncapsulation } from \'@angular/core\';\n\n@Component({\n  // ...\n  encapsulation: ViewEncapsulation.Emulated // or .ShadowDom for Ionic\n})\n```'
                  );
                }

                // Check for lifecycle interfaces
                const lifecycleHooks = ['OnInit', 'OnDestroy', 'AfterViewInit', 'OnChanges'];
                const implementedHooks = lifecycleHooks.filter(hook => content.includes(hook));
                const declaredInterfaces = content.includes('implements') ? 
                  content.match(/implements\s+([^{]+)/)[1].split(',').map(i => i.trim()) : [];
                
                const missingInterfaces = implementedHooks.filter(hook => 
                  !declaredInterfaces.includes(hook)
                );

                if (missingInterfaces.length > 0) {
                  await createComment(file, 1, 'recommended', 'Type Safety',
                    `Implement interfaces for used lifecycle hooks:\n\`\`\`typescript\nexport class HomePage implements ${missingInterfaces.join(', ')} {\n}\n\`\`\``
                  );
                }

                // Empty component checks
                if (content.match(/export\s+class\s+\w+\s*{[\s\n]*constructor\(\)\s*{}[\s\n]*}/)) {
                  await createComment(file, 1, 'optional', 'Component Structure',
                    'Consider adding proper lifecycle hooks and documentation for this component:\n```typescript\nexport class HomePage implements OnInit {\n  constructor() {}\n\n  ngOnInit() {\n    // Initialize component\n  }\n}\n```'
                  );
                }
              }

              // Observable Memory Leak Checks
              const subscribeLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => line.includes('subscribe'));
              
              const hasUnsubscribe = content.includes('unsubscribe()') || 
                                   content.includes('takeUntil') ||
                                   content.includes('| async');
              
              if (subscribeLines.length > 0 && !hasUnsubscribe) {
                for (const { index } of subscribeLines) {
                  await createComment(file, index, 'critical', 'Memory Leak Risk',
                    'Subscription not properly managed. Use takeUntil, async pipe, or manual unsubscription.'
                  );
                }
              }

              // Additional TypeScript checks...
              // (Rest of the TypeScript checks remain the same)
            }

            async function checkHtmlFile(file, content, lines) {
              // Track existing issues to prevent duplicates
              const reportedIssues = new Set();

              // Performance Checks
              const ngForLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => line.includes('*ngFor') && !line.includes('trackBy'));
              
              for (const { index } of ngForLines) {
                const issueKey = `${file.filename}:${index}:ngFor`;
                if (!reportedIssues.has(issueKey)) {
                  await createComment(file, index, 'critical', 'Performance',
                    'Add trackBy function to improve performance with *ngFor.'
                  );
                  reportedIssues.add(issueKey);
                }
              }

              // Ionic Responsive Design Checks
              const ionResponsivePatterns = [
                {
                  pattern: /<ion-(col|grid)[^>]*size="(12|"|\s)*"[^>]*>/,
                  exclude: /size-[s|m|l|x][mdlgx]=/,
                  message: 'Consider adding responsive breakpoints (size-sm, size-md, size-lg, size-xl) for better layout adaptation across different screen sizes. Example:\n```html\n<ion-col size="12" size-sm="6" size-md="4" size-lg="3">\n```'
                },
                {
                  pattern: /<ion-grid[^>]*>/,
                  exclude: /fixed|no-padding/,
                  message: 'Consider using `fixed` attribute for consistent container width or `no-padding` when nested grids are used. Example:\n```html\n<ion-grid fixed>\n```'
                },
                {
                  pattern: /<ion-row[^>]*>/,
                  exclude: /wrap|nowrap|reverse|align-items-|justify-content-/,
                  message: 'Consider adding flex properties for better responsive behavior:\n```html\n<ion-row wrap align-items-center justify-content-between>\n```'
                }
              ];

              for (const check of ionResponsivePatterns) {
                const matches = lines
                  .map((line, index) => ({ line, index: index + 1 }))
                  .filter(({ line }) => 
                    check.pattern.test(line) && 
                    (!check.exclude || !check.exclude.test(line))
                  );

                for (const { index } of matches) {
                  const issueKey = `${file.filename}:${index}:ionic-responsive`;
                  if (!reportedIssues.has(issueKey)) {
                    await createComment(file, index, 'recommended', 'Responsive Design',
                      check.message
                    );
                    reportedIssues.add(issueKey);
                  }
                }
              }

              // Accessibility checks with line tracking
              const accessibilityChecks = [
                {
                  pattern: /<img[^>]*(?!alt=)[^>]*>/,
                  message: 'IMG elements must have alt attributes'
                },
                {
                  pattern: /<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/,
                  message: 'BUTTON elements should have meaningful content'
                },
                {
                  pattern: /<input[^>]*(?!aria-label|id=)[^>]*>/,
                  message: 'INPUT elements must have proper accessibility attributes'
                }
              ];

              for (const check of accessibilityChecks) {
                const matches = lines
                  .map((line, index) => ({ line, index: index + 1 }))
                  .filter(({ line }) => check.pattern.test(line));

                for (const { index } of matches) {
                  const issueKey = `${file.filename}:${index}:${check.message}`;
                  if (!reportedIssues.has(issueKey)) {
                    await createComment(file, index, 'critical', 'Accessibility',
                      check.message
                    );
                    reportedIssues.add(issueKey);
                  }
                }
              }
            }

            async function checkStyleFile(file, content, lines) {
              const colorLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => /#[0-9a-fA-F]{3,6}/.test(line));

              for (const { index } of colorLines) {
                await createComment(file, index, 'optional', 'Style Management',
                  'Consider using CSS variables for better maintainability.'
                );
              }
            }

            // Process changed files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Filter for specific file extensions
            const allowedExtensions = ['ts', 'html', 'scss', 'css', 'js'];
            
            for (const file of files) {
              const fileExt = file.filename.split('.').pop().toLowerCase();
              if (file.status !== 'removed' && allowedExtensions.includes(fileExt)) {  // Skip deleted files and check extension
                const content = fs.readFileSync(file.filename, 'utf8');
                const lines = content.split('\n');
                const fileExt = file.filename.split('.').pop();
                
                await checkFileContent(file, content, lines, fileExt);
              }
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Get the list of files and their current content
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a map of file paths to their current content
            const fileContents = new Map();
            for (const file of files) {
              if (file.status !== 'removed') {
                try {
                  const content = fs.readFileSync(file.filename, 'utf8');
                  fileContents.set(file.filename, {
                    content,
                    lines: content.split('\n'),
                    status: file.status
                  });
                } catch (error) {
                  console.error(`Error reading file ${file.filename}: ${error}`);
                }
              }
            }

            async function verifyFix(comment) {
              const file = comment.path;
              const fileInfo = fileContents.get(file);
              
              // Handle removed files
              if (!fileInfo) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - File has been removed.',
                  in_reply_to: comment.id
                });
                return true;
              }

              const { content, lines, status } = fileInfo;
              
              // Handle removed or changed lines
              if (comment.line > lines.length || 
                  (status === 'modified' && !lines[comment.line - 1]?.includes(comment.original_line))) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - Code has been modified or removed.',
                  in_reply_to: comment.id
                });
                return true;
              }

              // Handle manual resolutions (comments with 'Resolved' or similar keywords)
              const conversationResolved = comments.some(reply => 
                reply.in_reply_to === comment.id && 
                /resolved|fixed|completed|done/i.test(reply.body)
              );
              
              if (conversationResolved) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - Manually marked as resolved.',
                  in_reply_to: comment.id
                });
                return true;
              }

              // Verification rules for specific issues
              const rules = {
                'Responsive Design': () => {
                  const line = lines[comment.line - 1] || '';
                  return line.includes('size-sm') || 
                         line.includes('size-md') || 
                         line.includes('size-lg') || 
                         line.includes('size-xl');
                },
                'Performance': () => {
                  if (comment.body.includes('trackBy')) {
                    return content.includes('trackBy');
                  }
                  return false;
                },
                // Add other specific rules...
              };

              const category = Object.keys(rules).find(key => comment.body.includes(key));
              return category ? rules[category]() : false;
            }

            // Process each comment
            for (const comment of comments) {
              try {
                // Skip already resolved comments
                if (comment.body.includes('âœ…')) continue;
                
                const isFixed = await verifyFix(comment);
                if (isFixed) {
                  // Mark the comment as resolved by adding a checkmark
                  core.info(`Resolved comment in ${comment.path} at line ${comment.line}`);
                }
              } catch (error) {
                console.error(`Error processing comment: ${error}`);
              }
            }

            // Check remaining critical issues (only count unresolved ones)
            const criticalIssues = comments.filter(comment => 
              !comment.body.includes('âœ…') && // Not marked as resolved
              comment.body.includes('ðŸš¨ CRITICAL') && 
              !comments.some(reply => // No resolution reply
                reply.in_reply_to === comment.id && 
                (reply.body.includes('âœ…') || /resolved|fixed|completed|done/i.test(reply.body))
              )
            );

            if (criticalIssues.length > 0) {
              core.setFailed('Critical issues must be resolved before merging.');
            }