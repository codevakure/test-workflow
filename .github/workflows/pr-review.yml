name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - "**.ts"
      - "**.js"
      - "**.html"
      - "**.scss"
      - "**.css"

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        id: review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            
            let criticalIssuesFound = false;
            let unresolvedCriticalIssues = 0;
            const criticalIssues = [];

            // Create initial check run
            const { data: check } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: "Ionic/Angular PR Review",
              head_sha: context.payload.pull_request.head.sha,
              status: "in_progress",
              started_at: new Date().toISOString(),
            });

            async function createComment(github, context, file, line, priority, category, message) {
              const priorityEmoji = {
                critical: "ðŸš¨ CRITICAL: ",
                recommended: "ðŸ’¡ RECOMMENDED: ",
                optional: "ðŸ’­ OPTIONAL: ",
              };

              try {
                const { data: pullRequest } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                });
                
                if (priority === "critical") {
                  criticalIssuesFound = true;
                  criticalIssues.push(`${file.filename}:${line} - ${category}`);
                }

                await github.rest.pulls.createReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  commit_id: pullRequest.head.sha,
                  path: file.filename,
                  body: `${priorityEmoji[priority]}**${category}**\n\n${message}`,
                  line: line,
                  side: "RIGHT",
                });
              } catch (error) {
                console.error(`Failed to create review comment: ${error.message}`);
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `In file \`${file.filename}\` line ${line}:\n\n${priorityEmoji[priority]}**${category}**\n\n${message}`,
                });
              }
            }

            async function isManuallyResolved(github, context, comment) {
              try {
                // Check for resolution keywords in subsequent comments
                const { data: replies } = await github.rest.pulls.listReviewComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  since: comment.created_at,
                });

                const hasResolutionReply = replies.some(reply => 
                  reply.in_reply_to_id === comment.id && 
                  /resolved|fixed|done|completed/i.test(reply.body)
                );

                if (hasResolutionReply) return true;

                // Check for resolution reactions
                const { data: reactions } = await github.rest.reactions.listForPullRequestReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id,
                });

                return reactions.some(reaction => 
                  reaction.content === '+1' || 
                  reaction.content === 'hooray'
                );
              } catch (error) {
                console.error(`Error checking manual resolution: ${error.message}`);
                return false;
              }
            }

            async function verifyFix(file, comment) {
              try {
                const content = fs.readFileSync(file, "utf8");
                const category = comment.body.match(/\*\*(.*?)\*\*/)?.[1];
                if (!category) return false;

                const verificationRules = {
                  "Security Risk": (content) => {
                    if (comment.body.includes("innerHTML")) {
                      return !content.match(/\.[a-zA-Z]+\.innerHTML\s*=/) &&
                             !content.match(/\[innerHTML\]\s*=/) &&
                             !content.match(/innerHTML\s*=\s*['"]/);
                    }
                    if (comment.body.includes("bypassSecurityTrust")) {
                      return !content.match(/bypassSecurityTrust\w+\s*\(/);
                    }
                    return false;
                  },
                  "Memory Leak Risk": (content) => {
                    return content.includes("takeUntil") ||
                           content.includes("| async") ||
                           (content.includes("unsubscribe()") && content.includes("ngOnDestroy"));
                  },
                  "Performance": (content) => {
                    if (comment.body.includes("trackBy")) {
                      return content.includes("trackBy");
                    }
                    return false;
                  },
                  "Accessibility": (content) => {
                    if (comment.body.includes("IMG")) {
                      return !/<img[^>]*(?!alt=)[^>]*>/g.test(content);
                    }
                    if (comment.body.includes("BUTTON")) {
                      return !/<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/g.test(content);
                    }
                    if (comment.body.includes("INPUT")) {
                      return !/<input[^>]*(?!aria-label|id=)[^>]*>/g.test(content);
                    }
                    return false;
                  },
                };

                return verificationRules[category]?.(content) ?? false;
              } catch (error) {
                console.error(`Error verifying fix: ${error.message}`);
                return false;
              }
            }

            // Function to process comments and update status
            async function processComments() {
              const { data: comments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
              });

              // Track which files have been modified since comments were made
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
              });

              const modifiedFiles = new Set(files.map(file => file.filename));

              for (const comment of comments) {
                try {
                  // Skip already resolved comments
                  if (comment.body.includes("âœ… Issue resolved")) continue;

                  // Only process our automated comments
                  if (!comment.body.includes("CRITICAL:") && 
                      !comment.body.includes("RECOMMENDED:") && 
                      !comment.body.includes("OPTIONAL:")) continue;

                  // Skip comments on files that haven't been modified
                  if (!modifiedFiles.has(comment.path)) {
                    if (comment.body.includes("CRITICAL:")) {
                      unresolvedCriticalIssues++;
                    }
                    continue;
                  }

                  const isFixed = await verifyFix(comment.path, comment);
                  
                  if (isFixed) {
                    // Get comment reactions to check if it was manually resolved
                    const { data: reactions } = await github.rest.reactions.listForPullRequestReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.id,
                    });

                    const hasResolutionReaction = reactions.some(reaction => 
                      reaction.content === '+1' || reaction.content === 'hooray'
                    );

                    // If not manually resolved, mark as auto-resolved
                    if (!hasResolutionReaction) {
                      await github.rest.pulls.updateReviewComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        comment_id: comment.id,
                        body: `${comment.body}\n\nâœ… Issue resolved automatically based on implemented changes.`,
                      });

                      // Add a visual checkmark reaction
                      await github.rest.reactions.createForPullRequestReviewComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        comment_id: comment.id,
                        content: 'hooray',
                      });
                    }
                  } else if (comment.body.includes("CRITICAL:")) {
                    unresolvedCriticalIssues++;
                  }
                } catch (error) {
                  console.error(`Error processing comment: ${error.message}`);
                  // Only increment unresolved issues for critical ones
                  if (comment.body.includes("CRITICAL:")) {
                    unresolvedCriticalIssues++;
                  }
                }
              }

              // Update check status based on latest findings
              const checkOutput = {
                title: unresolvedCriticalIssues > 0 ? "ðŸš¨ Critical Issues Found" : "âœ… No Critical Issues",
                summary: unresolvedCriticalIssues > 0 
                  ? `${unresolvedCriticalIssues} critical issues must be resolved before merging.`
                  : "No critical issues found in the code review.",
              };

              await github.rest.checks.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: check.id,
                status: "completed",
                conclusion: unresolvedCriticalIssues > 0 ? "failure" : "success",
                completed_at: new Date().toISOString(),
                output: checkOutput,
              });

              if (unresolvedCriticalIssues > 0) {
                core.setFailed("Critical issues must be resolved before merging.");
              }
            }

            // Process all files in the PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            for (const file of files) {
              try {
                const content = fs.readFileSync(file.filename, "utf8");
                const lines = content.split("\n");
                const fileExt = file.filename.split(".").pop();
                
                await checkFileContent(github, context, file, content, lines, fileExt);
              } catch (error) {
                console.error(`Error processing file ${file.filename}: ${error.message}`);
              }
            }

            // Process and verify comments after all files are checked
            await processComments();