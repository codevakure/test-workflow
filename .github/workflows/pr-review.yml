name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - "**.ts"
      - "**.js"
      - "**.html"
      - "**.scss"
      - "**.css"

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        id: review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            
            let criticalIssuesFound = false;
            let unresolvedCriticalIssues = 0;
            const criticalIssues = [];

            // Create initial check run
            const { data: check } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: "Ionic/Angular PR Review",
              head_sha: context.payload.pull_request.head.sha,
              status: "in_progress",
              started_at: new Date().toISOString(),
            });

            async function createComment(github, context, file, line, priority, category, message) {
              const commentKey = `${file.filename}:${line}:${category}`;
              
              const priorityEmoji = {
                critical: "ðŸš¨ CRITICAL: ",
                recommended: "ðŸ’¡ RECOMMENDED: ",
                optional: "ðŸ’­ OPTIONAL: ",
              };

              try {
                const { data: pullRequest } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                });
                
                if (priority === "critical") {
                  criticalIssuesFound = true;
                  criticalIssues.push(`${file.filename}:${line} - ${category}`);
                }

                await github.rest.pulls.createReviewComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  commit_id: pullRequest.head.sha,
                  path: file.filename,
                  body: `${priorityEmoji[priority]}**${category}**\n\n${message}`,
                  line: line,
                  side: "RIGHT",
                });
              } catch (error) {
                console.error(`Failed to create review comment: ${error.message}`);
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `In file \`${file.filename}\` line ${line}:\n\n${priorityEmoji[priority]}**${category}**\n\n${message}`,
                });
              }
            }

            async function checkTypeScriptFile(github, context, file, content, lines) {
              // XSS and Security Checks
              if (content.includes("innerHTML") || content.includes("bypassSecurityTrust")) {
                const securityIssues = [];
                
                // Check innerHTML usage
                const innerHTMLLines = lines
                  .map((line, idx) => ({ line, idx }))
                  .filter(({ line }) => line.includes("innerHTML"));
                  
                innerHTMLLines.forEach(({ line, idx }) => {
                  securityIssues.push({
                    line: idx + 1,
                    message: "Potential XSS vulnerability. Use Angular's built-in sanitization:\n```typescript\n" +
                            "import { DomSanitizer } from '@angular/platform-browser';\n" +
                            "content = this.sanitizer.sanitize(SecurityContext.HTML, userInput);\n```"
                  });
                });

                // Check sanitizer bypass
                const bypassLines = lines
                  .map((line, idx) => ({ line, idx }))
                  .filter(({ line }) => line.includes("bypassSecurityTrust"));

                bypassLines.forEach(({ line, idx }) => {
                  if (!line.includes("// security-reviewed") && !line.includes("/* security-reviewed */")) {
                    securityIssues.push({
                      line: idx + 1,
                      message: "Bypassing security sanitization detected. If this is intentional, add a '// security-reviewed' comment."
                    });
                  }
                });

                // Report security issues
                for (const issue of securityIssues) {
                  await createComment(
                    github, context, file, issue.line,
                    "critical", "Security Risk",
                    issue.message
                  );
                }
              }

              // Observable Memory Leak Checks
              const subscriptions = content.match(/subscribe\s*\(/g);
              const hasUnsubscribe = content.includes("unsubscribe()") || 
                                   content.includes("takeUntil") ||
                                   content.includes("| async");
              
              if (subscriptions && !hasUnsubscribe) {
                const lineIndex = lines.findIndex(line => line.includes("subscribe")) + 1;
                await createComment(
                  github, context, file, lineIndex,
                  "critical", "Memory Leak Risk",
                  "Observable subscription not properly managed. Use takeUntil, async pipe, or manual unsubscribe."
                );
              }

              // Form Validation Checks
              if (content.includes("@Component") && content.includes("FormGroup")) {
                const formLines = lines.filter((line, idx) => line.includes("FormGroup"));
                for (const line of formLines) {
                  if (!content.includes("Validators.") || !content.includes("hasError")) {
                    await createComment(
                      github, context, file, lines.indexOf(line) + 1,
                      "critical", "Form Validation",
                      "Form lacks proper validation or error handling."
                    );
                  }
                }
              }

              // Change Detection Strategy
              if (content.includes("@Component")) {
                const hasComplexity = 
                  content.includes("@Input") || 
                  content.includes("@Output") || 
                  content.includes("*ngFor") || 
                  content.includes("*ngIf");
                  
                if (hasComplexity && !content.includes("ChangeDetectionStrategy.OnPush")) {
                  const componentLine = lines.findIndex(line => line.includes("@Component")) + 1;
                  await createComment(
                    github, context, file, componentLine,
                    "recommended", "Performance",
                    "Consider using OnPush change detection for better performance."
                  );
                }
              }

              // NgRx Store Pattern Checks
              if (content.includes("@Effect") || content.includes("createEffect")) {
                const effectLines = lines.filter(line => 
                  line.includes("@Effect") || line.includes("createEffect")
                );
                
                for (const line of effectLines) {
                  if (!line.includes("catchError")) {
                    await createComment(
                      github, context, file, lines.indexOf(line) + 1,
                      "recommended", "Error Handling",
                      "Effects should handle potential errors using catchError operator."
                    );
                  }
                }
              }
            }

            async function checkHtmlFile(github, context, file, content, lines) {
              // Accessibility Checks
              const imgWithoutAlt = /<img[^>]*(?!alt=)[^>]*>/g;
              const buttonWithoutLabel = /<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/g;
              const inputWithoutLabel = /<input[^>]*(?!aria-label|id=)[^>]*>/g;

              if (imgWithoutAlt.test(content)) {
                const lineNumber = lines.findIndex(line => imgWithoutAlt.test(line)) + 1;
                await createComment(
                  github, context, file, lineNumber,
                  "critical", "Accessibility",
                  "IMG elements must have alt attributes for screen readers."
                );
              }

              // Performance Checks
              if (content.includes("*ngFor") && !content.includes("trackBy")) {
                const lineNumber = lines.findIndex(line => line.includes("*ngFor")) + 1;
                await createComment(
                  github, context, file, lineNumber,
                  "recommended", "Performance",
                  "Add trackBy function to *ngFor for better performance."
                );
              }

              // Ionic Grid Checks
              lines.forEach(async (line, index) => {
                // Check for ion-col without ion-row parent
                if (line.includes("<ion-col") && !content.includes("<ion-row")) {
                  await createComment(
                    github, context, file, index + 1,
                    "critical", "Grid Structure",
                    "ion-col must be inside an ion-row element."
                  );
                }

                // Check column sizing
                if (line.includes("<ion-row")) {
                  let totalSize = 0;
                  let rowContent = "";
                  let i = index;
                  while (i < lines.length && !lines[i].includes("</ion-row>")) {
                    rowContent += lines[i];
                    i++;
                  }
                  
                  const sizeMatches = rowContent.match(/size="(\d+)"/g);
                  if (sizeMatches) {
                    totalSize = sizeMatches
                      .map(match => parseInt(match.match(/\d+/)[0]))
                      .reduce((a, b) => a + b, 0);
                      
                    if (totalSize > 12) {
                      await createComment(
                        github, context, file, index + 1,
                        "critical", "Grid Structure",
                        "Total column size exceeds 12 units in this row."
                      );
                    }
                  }
                }

                // Check responsive breakpoints
                if (line.includes("<ion-col") && line.includes('size="12"')) {
                  const hasResponsive = 
                    line.includes("size-sm") || 
                    line.includes("size-md") || 
                    line.includes("size-lg");
                    
                  if (!hasResponsive) {
                    await createComment(
                      github, context, file, index + 1,
                      "recommended", "Responsive Design",
                      "Consider adding responsive breakpoints for better mobile layout."
                    );
                  }
                }
              });
            }

            async function checkStyleFile(github, context, file, content, lines) {
              // Check for hardcoded values
              const hardcodedColors = content.match(/#[0-9a-fA-F]{3,6}/g);
              if (hardcodedColors) {
                const uniqueColorLines = new Map();
                lines.forEach((line, index) => {
                  hardcodedColors.forEach(color => {
                    if (line.includes(color) && !uniqueColorLines.has(color)) {
                      uniqueColorLines.set(color, index + 1);
                    }
                  });
                });

                for (const [color, lineNumber] of uniqueColorLines) {
                  await createComment(
                    github, context, file, lineNumber,
                    "optional", "Style Management",
                    "Consider using CSS variables for better maintainability."
                  );
                }
              }

              // Check media queries
              if (!content.includes("@media")) {
                await createComment(
                  github, context, file, 1,
                  "recommended", "Responsive Design",
                  "Consider adding media queries for responsive styling."
                );
              }
            }

            async function verifyFix(file, comment) {
              try {
                const content = fs.readFileSync(file, "utf8");
                const category = comment.body.match(/\*\*(.*?)\*\*/)?.[1];
                if (!category) return false;

                const verificationRules = {
                  "Security Risk": (content) => {
                    if (comment.body.includes("innerHTML")) {
                      return !content.match(/\.[a-zA-Z]+\.innerHTML\s*=/) &&
                             !content.match(/\[innerHTML\]\s*=/) &&
                             !content.match(/innerHTML\s*=\s*['"]/);
                    }
                    if (comment.body.includes("bypassSecurityTrust")) {
                      return !content.match(/bypassSecurityTrust\w+\s*\(/);
                    }
                    return false;
                  },
                  "Memory Leak Risk": (content) => {
                    return content.includes("takeUntil") ||
                           content.includes("| async") ||
                           (content.includes("unsubscribe()") && content.includes("ngOnDestroy"));
                  },
                  "Grid Structure": (content) => {
                    if (comment.body.includes("ion-col must be inside")) {
                      return content.includes("<ion-row");
                    }
                    if (comment.body.includes("exceeds 12 units")) {
                      // Verify column sizes
                      const sizes = content.match(/size="(\d+)"/g);
                      if (!sizes) return true;
                      const total = sizes
                        .map(s => parseInt(s.match(/\d+/)[0]))
                        .reduce((a, b) => a + b, 0);
                      return total <= 12;
                    }
                    return false;
                  }
                };

                return verificationRules[category]?.(content) ?? false;
              } catch (error) {
                console.error(`Error verifying fix: ${error.message}`);
                return false;
              }
            }

            async function processComments() {
              const { data: comments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
              });

              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
              });

              const modifiedFiles = new Map(files.map(file => [file.filename, file]));

              for (const comment of comments) {
                try {
                  if (comment.body.includes("âœ… Issue resolved")) continue;

                  const file = modifiedFiles.get(comment.path);
                  if (!file && comment.body.includes("CRITICAL:")) {
                    unresolvedCriticalIssues++;
                    continue;
                  }

                  const isFixed = await verifyFix(comment.path, comment);
                  if (isFixed) {
                    await github.rest.pulls.updateReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.id,
                      body: `${comment.body}\n\nâœ… Issue resolved automatically based on implemented changes.`,
                    });

                    await github.rest.reactions.createForPullRequestReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.id,
                      content: "hooray",
                    });
                  } else if (comment.body.includes("CRITICAL:")) {
                    unresolvedCriticalIssues++;
                  }
                } catch (error) {
                  console.error(`Error processing comment: ${error.message}`);
                  if (comment.body.includes("CRITICAL:")) {
                    unresolvedCriticalIssues++;
                  }
                }
              }

              // Update check status based on unresolved issues
              const checkOutput = {
                title: unresolvedCriticalIssues > 0 ? "ðŸš¨ Critical Issues Found" : "âœ… No Critical Issues",
                summary: unresolvedCriticalIssues > 0 
                  ? `${unresolvedCriticalIssues} critical issues must be resolved before merging.`
                  : "No critical issues found in the code review.",
              };

              await github.rest.checks.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: check.id,
                status: "completed",
                conclusion: unresolvedCriticalIssues > 0 ? "failure" : "success",
                completed_at: new Date().toISOString(),
                output: checkOutput,
              });

              if (unresolvedCriticalIssues > 0) {
                core.setFailed("Critical issues must be resolved before merging.");
              }
            }

            // Process all files in the PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            for (const file of files) {
              try {
                // Skip test files and workflow files
                if (file.filename.includes(".spec.") || 
                    file.filename.includes(".test.") || 
                    file.filename.includes(".github/workflows/")) {
                  continue;
                }

                const content = fs.readFileSync(file.filename, "utf8");
                const lines = content.split("\n");
                const fileExt = file.filename.split(".").pop();

                // Run appropriate checks based on file type
                switch (fileExt) {
                  case "ts":
                  case "js":
                    await checkTypeScriptFile(github, context, file, content, lines);
                    break;
                  case "html":
                    await checkHtmlFile(github, context, file, content, lines);
                    break;
                  case "scss":
                  case "css":
                    await checkStyleFile(github, context, file, content, lines);
                    break;
                }
              } catch (error) {
                console.error(`Error processing file ${file.filename}: ${error.message}`);
              }
            }

            // Process and verify comments after all files are checked
            await processComments();