name: Ionic/Angular PR Review v12

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'
      - '**.js'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install


      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get PR information
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;
            
            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a Set of existing comments
            const existingComments = new Set(
              comments.map(comment => `${comment.path}:${comment.line}:${comment.body}`)
            );

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              const commentBody = `${priorityEmoji[priority]}**${category}**\n\n${message}`;
              const commentKey = `${file.filename}:${line}:${commentBody}`;
              
              if (!existingComments.has(commentKey)) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: file.filename,
                  body: commentBody,
                  line: line
                });
              }
            }

            async function checkTypeScriptFile(file, content, lines) {
                  // Check for memory leaks in subscriptions
                  const subscribeLines = lines
                        .map((line, index) => ({ line, index: index + 1 }))
                        .filter(({ line }) => {
                              const isComment = line.trim().startsWith('//') || line.trim().startsWith('/*');
                              const isActualSubscribe = /\.subscribe\s*\(/.test(line);
                              return !isComment && isActualSubscribe;
                        });

                  for (const { line, index } of subscribeLines) {
                        const relevantContent = content.split('\n')
                              .slice(Math.max(0, index - 10), index + 10)
                              .join('\n'); // Look at surrounding context

                        const hasUnsubscribe = 
                              /\.pipe\s*\(\s*takeUntil\s*\(/.test(relevantContent) ||
                              /\|\s*async/.test(content) ||
                              /ngOnDestroy\s*\(\s*\)\s*{[^}]*this\.[^.]+\.unsubscribe\s*\(\s*\)/.test(content);

                        if (!hasUnsubscribe) {
                              await createComment(file, index, 'critical', 'Memory Leak Risk', 
                                     `This subscription at ${file.filename}:${index} lacks proper cleanup.\n` + 
                                     `Memory leaks occur when subscriptions remain active after component destruction.\n` +
                                     `You should:\n\n` +
                                     `1. Use .pipe(takeUntil(this.destroy$)) pattern\n` +
                                     `2. OR use the async pipe in template\n` +
                                     `3. OR manually unsubscribe in ngOnDestroy`);
                        }
                  }

                  // Check for security vulnerabilities
                  const securityLines = lines
                        .map((line, index) => ({ line, index: index + 1 }))
                        .filter(({ line }) => {
                              if (line.trim().startsWith('//') || line.trim().startsWith('/*')) return false;
                              return /\binnerHTML\s*=/.test(line) || /bypassSecurityTrust\w+\s*\(/.test(line) || 
                                     /\bdocument\.write\s*\(/.test(line) || /eval\s*\(/.test(line);
                        });

                  for (const { line, index } of securityLines) {
                        const isInnerHTML = /\binnerHTML\s*=/.test(line);
                        const message = isInnerHTML ? 
                              `Direct innerHTML manipulation at ${file.filename}:${index} creates an XSS vulnerability.` :
                              `Bypassing security sanitization at ${file.filename}:${index} is dangerous.`;

                        await createComment(file, index, 'critical', 'Security Risk', message);
                  }

                  // Check for unsafe eval usage
                  const evalLines = lines
                        .map((line, index) => ({ line, index: index + 1 }))
                        .filter(({ line }) => /eval\s*\(/.test(line));

                  for (const { line, index } of evalLines) {
                        await createComment(file, index, 'critical', 'Security Risk', 
                               `The use of eval() at ${file.filename}:${index} can lead to security risks. Avoid dynamic code execution.`);
                  }

                  // Check for possible 'any' types for stricter typing
                  const anyTypeLines = lines
                        .map((line, index) => ({ line, index: index + 1 }))
                        .filter(({ line }) => /\bany\s+/.test(line));

                  for (const { line, index } of anyTypeLines) {
                        await createComment(file, index, 'recommended', 'Type Safety', 
                               `The use of 'any' type at ${file.filename}:${index} reduces type safety. Specify a more specific type.`);
                  }
            }

            async function checkHtmlFile(file, content, lines) {
              // Check for repeated string literals in *ngIf
              const stringLiteralsMap = new Map();

              lines.forEach((line, index) => {
                if (line.includes('*ngIf')) {
                  const stringPattern = /[=!]=\s*['"]([^'"]+)['"]/g;
                  let match;
                  while ((match = stringPattern.exec(line)) !== null) {
                    const value = match[1];
                    if (!stringLiteralsMap.has(value)) {
                      stringLiteralsMap.set(value, []);
                    }
                    stringLiteralsMap.get(value).push(index + 1);
                  }
                }
              });

              for (const [literal, lineNumbers] of stringLiteralsMap.entries()) {
                if (lineNumbers.length >= 2) {
                  const enumName = literal.includes('-') ? 
                    literal.split('-')[0].toUpperCase() : 
                    literal.toUpperCase();
                  
                  await createComment(
                    file,
                    lineNumbers[0],
                    'recommended',
                    'String Literal Optimization',
                    `String literal '${literal}' is used ${lineNumbers.length} times in *ngIf conditions.\n\n` +
                    `To improve type safety and maintainability, create an enum:\n\n` +
                    `\`\`\`typescript\nenum ${enumName}Status {\n` +
                    `  ${literal.toUpperCase().replace(/-/g, '_')} = '${literal}'\n` +
                    `}\n\`\`\`\n\n` +
                    `Then update the template to use:\n` +
                    `\`\`\`html\n*ngIf="variable === ${enumName}Status.${literal.toUpperCase().replace(/-/g, '_')}"\n\`\`\`\n\n` +
                    `Found on lines: ${lineNumbers.join(', ')}`
                  );
                }
              }

              // Check for responsive design patterns
              const responsiveLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  if (line.trim().startsWith('<!--')) return false;
                  return line.includes('ion-col') && 
                         (line.includes('size="') || line.includes('size=\''));
                });

              for (const { index, line } of responsiveLines) {
                await createComment(file, index, 'recommended', 'Responsive Design',
                  `Hardcoded ion-col size detected. For better responsive design:\n\n` +
                  `\`\`\`html\n` +
                  `<ion-col \n` +
                  `  size="12"\n` +
                  `  size-sm="6"\n` +
                  `  size-md="4"\n` +
                  `  size-lg="3"\n` +
                  `>\n` +
                  `</ion-col>\n` +
                  `\`\`\``
                );
              }

              // Check performance issues in templates
              const ngForLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  const hasNgFor = line.includes('*ngFor');
                  const hasTrackBy = line.includes('trackBy');
                  const hasComplexBinding = (line.match(/{{.*}}/g) || []).length > 1;
                  return hasNgFor && !hasTrackBy && hasComplexBinding;
                });

              for (const { index } of ngForLines) {
                await createComment(file, index, 'recommended', 'Performance',
                  'Add trackBy function to improve rendering performance with complex *ngFor.'
                );
              }

              // Check accessibility issues
              // Check accessibility issues for form elements, buttons, select, images, and text-containing elements
               for (let i = 0; i < lines.length; i++) {
                      const line = lines[i];
                      if (line.trim().startsWith('<!--')) continue;

                      // Check for <img> elements - Ensure alt text is present or the image is marked as decorative
                      if (line.includes('<img') && !line.includes('alt=')) {
                             await createComment(file, i + 1, 'critical', 'Accessibility',
                                    'Add alt attribute to image for screen reader support. ' +
                                    'Example: <img src="image.jpg" alt="Description of the image">'
                             );
                      }

                      // Check for buttons - Ensure aria-label, id, or proper accessible name
                      if (line.includes('<button') && !line.includes('aria-label') && !line.includes('id=')) {
                             await createComment(file, i + 1, 'critical', 'Accessibility',
                                    'Button needs aria-label or id for screen reader support and automation. ' +
                                    'Example: <button id="submitButton" aria-label="Submit form">Submit</button>'
                             );
                      }

                      // Check for select elements - Ensure aria-label, id, or associated label
                      if (line.includes('<select') && !line.includes('aria-label') && !line.includes('id=')) {
                             await createComment(file, i + 1, 'critical', 'Accessibility',
                                    'Select element needs aria-label or id for screen reader support and automation. ' +
                                    'Example: <select id="dropdown" aria-label="Select a country"><option>USA</option></select>'
                             );
                      }

                      // Check for form elements - Ensure id is present for accessibility and automation
                      if (line.includes('<input') && !line.includes('aria-label') && !line.includes('id=')) {
                             await createComment(file, i + 1, 'critical', 'Accessibility',
                                    'Input element needs an associated label, aria-label, or id for accessibility and automation. ' +
                                    'Example: <input type="text" id="username" aria-label="Enter your username">'
                             );
                      }

                      // Check for text-containing elements (headings, paragraphs, links) - Ensure proper structure and ids for automation
                      if (line.includes('<h') && !line.includes('id=')) {
                             await createComment(file, i + 1, 'recommended', 'Accessibility',
                                    'Heading should ideally have an id for automation and accessibility purposes. ' +
                                    'Example: <h2 id="section2">Section 2: Introduction</h2>'
                             );
                      }

                      if (line.includes('<p') && !line.includes('id=')) {
                             await createComment(file, i + 1, 'recommended', 'Accessibility',
                                    'Paragraph should ideally have an id for automation and accessibility purposes, especially if it contains important content. ' +
                                    'Example: <p id="intro">This is the introduction paragraph.</p>'
                             );
                      }

                      if (line.includes('<a')) {
                             // Check if the <a> tag has an href attribute
                             if (!line.includes('href=')) {
                                    await createComment(file, i + 1, 'critical', 'Accessibility',
                                           'Anchor tag ( <a> ) needs an href attribute to function as a link. ' +
                                           'Example: <a href="#contact">Go to Contact Section</a>'
                                    );
                             }

                             // Check if the <a> tag needs an aria-label
                             if (line.includes('<a') && !line.includes('aria-label') && (line.includes('<img') || line.includes('>Click here<'))) {
                                    await createComment(file, i + 1, 'critical', 'Accessibility',
                                           'Anchor tag needs an aria-label or text content that clearly describes the linkâ€™s purpose. ' +
                                           'Example: <a href="#more-info" aria-label="Learn more about our services">Click here</a>'
                                    );
                             }
                      }
               }

              // Check for dangerous innerHTML bindings
              const innerHtmlLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  const isComment = line.trim().startsWith('<!--');
                  const hasInnerHtml = line.includes('[innerHTML]');
                  return !isComment && hasInnerHtml;
                });

              for (const { index } of innerHtmlLines) {
                await createComment(file, index, 'critical', 'Security Risk',
                  'Using [innerHTML] can lead to XSS vulnerabilities. Use Angular\'s DomSanitizer or a safe pipe instead.'
                );
              }
            }

            async function checkStyleFile(file, content, lines) {
              // Check for !important usage
              const importantLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  // Ignore comments
                  if (line.trim().startsWith('//') || line.trim().startsWith('/*')) return false;
                  if (line.includes('*/')) return false;
                  
                  // Match !important in actual CSS rules
                  return /:\s*[^;]+!\s*important\s*;/.test(line);
                });

              for (const { line, index } of importantLines) {
                await createComment(file, index, 'recommended', 'CSS Best Practices',
                  `\`!important\` declaration found. Consider using more specific selectors or restructuring your CSS. This helps maintain better cascade and specificity control.`
                );
              }

              // Check for hardcoded color values
              const colorLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  // Ignore comments
                  if (line.trim().startsWith('//') || line.trim().startsWith('/*')) return false;
                  
                  // Match hex colors, rgb, rgba, hsl, hsla
                  return /(#[0-9a-f]{3,8}|rgb\(|rgba\(|hsl\(|hsla\()/i.test(line) &&
                         !line.includes('var(--');
                });

              for (const { line, index } of colorLines) {
                await createComment(file, index, 'recommended', 'Theme Variables',
                  `Hardcoded color value detected. Use theme variables for consistent styling:\n\n` +
                  `\`\`\`scss\n` +
                  `:root {\n` +
                  `  --ion-color-primary: #3880ff;\n` +
                  `  --ion-color-secondary: #3dc2ff;\n` +
                  `  // Add your custom color variables\n` +
                  `  --app-specific-color: #yourcolor;\n` +
                  `}\n\n` +
                  `// Then use them in your styles:\n` +
                  `color: var(--ion-color-primary);\n` +
                  `background: var(--app-specific-color);\n` +
                  `\`\`\``
                );
              }
            }

            // Process files
            for (const file of files) {
              try {
                if (file.status === 'removed') continue;
                
                const content = await fs.promises.readFile(file.filename, 'utf8');
                const lines = content.split('\n');
                const extension = file.filename.split('.').pop().toLowerCase();

                switch (extension) {
                  case 'ts':
                    await checkTypeScriptFile(file, content, lines);
                    break;
                  case 'html':
                    await checkHtmlFile(file, content, lines);
                    break;
                  case 'scss':
                  case 'css':
                    await checkStyleFile(file, content, lines);
                    break;
                }
              } catch (error) {
                console.error(`Error processing file ${file.filename}:`, error);
              }
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize' || github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // Get PR information
              const { data: pr } = await github.rest.pulls.get({
                ...context.repo,
                pull_number: context.issue.number,
              });

              // Get all review comments
              const { data: comments } = await github.rest.pulls.listReviewComments({
                ...context.repo,
                pull_number: context.issue.number,
              });

              // Get all reviews to check for resolved conversations
              const { data: reviews } = await github.rest.pulls.listReviews({
                ...context.repo,
                pull_number: context.issue.number,
              });

              // Get full PR details to check for resolved comments
              const { data: pullRequest } = await github.rest.pulls.get({
                ...context.repo,
                pull_number: context.issue.number,
                headers: {
                  accept: 'application/vnd.github.comfort-fade-preview+json'
                }
              });

              // Get changed files
              const { data: files } = await github.rest.pulls.listFiles({
                ...context.repo,
                pull_number: context.issue.number,
              });

              // Create sets for tracking resolved and outdated comments
              const resolvedCommentIds = new Set();
              const outdatedCommentIds = new Set();

              // Function to check if a comment path and line match a resolved comment
              function isCommentResolved(comment) {
                // Check if comment is outdated
                if (comment.position === null) {
                  return true;
                }

                // Check for resolution replies
                const hasResolutionReply = comments.some(reply => 
                  reply.in_reply_to === comment.id && 
                  (
                    /resolved|fixed|completed|done|Issue resolved/i.test(reply.body) ||
                    reply.body.includes('âœ…') ||
                    reply.body.includes('has been fixed') ||
                    reply.body.includes('Resolve conversation')
                  )
                );

                if (hasResolutionReply) {
                  return true;
                }

                // Check if the comment's review was dismissed
                const parentReview = reviews.find(review => review.id === comment.pull_request_review_id);
                if (parentReview && parentReview.state === 'DISMISSED') {
                  return true;
                }

                // Check if comment is in a resolved thread
                const reviewThreads = pullRequest.review_threads || [];
                return reviewThreads.some(thread => 
                  thread.comments.some(threadComment => 
                    threadComment.id === comment.id && thread.resolved
                  )
                );
              }

              // Track resolved and outdated comments
              comments.forEach(comment => {
                if (isCommentResolved(comment)) {
                  resolvedCommentIds.add(comment.id);
                }
                if (comment.position === null) {
                  outdatedCommentIds.add(comment.id);
                }
              });

              // Process all comments
              for (const comment of comments) {
                // Skip non-bot comments
                if (comment.user.login !== 'github-actions[bot]') continue;

                const isResolved = resolvedCommentIds.has(comment.id);
                const isOutdated = outdatedCommentIds.has(comment.id);

                if (isResolved || isOutdated) {
                  try {
                    await github.rest.pulls.deleteReviewComment({
                      ...context.repo,
                      comment_id: comment.id
                    });
                    core.info(`Deleted ${isOutdated ? 'outdated' : 'resolved'} comment: ${comment.path}:${comment.line}`);
                  } catch (error) {
                    core.warning(`Failed to delete comment ${comment.id}: ${error.message}`);
                  }
                }
              }

              // Get final remaining comments after cleanup
              const { data: finalComments } = await github.rest.pulls.listReviewComments({
                ...context.repo,
                pull_number: context.issue.number,
              });

              // Filter for remaining critical issues
              const criticalIssues = finalComments.filter(comment => {
                if (comment.user.login !== 'github-actions[bot]' || !comment.body.includes('ðŸš¨ CRITICAL')) {
                  return false;
                }
                
                // Check if this comment has been resolved
                if (resolvedCommentIds.has(comment.id) || outdatedCommentIds.has(comment.id)) {
                  return false;
                }

                // Additional check for manual resolution
                if (isCommentResolved(comment)) {
                  return false;
                }

                return true;
              });

              // Log remaining issues and fail if critical issues exist
              if (criticalIssues.length > 0) {
                core.info('Found remaining critical issues:');
                criticalIssues.forEach(issue => {
                  core.info(`- ${issue.path}:${issue.line} - ${issue.body.split('\n')[0]}`);
                });
                core.setFailed(`${criticalIssues.length} critical issues must be resolved before merging.`);
              } else {
                core.info('All critical issues have been resolved.');
              }
            } catch (error) {
              core.setFailed(`Error in verification step: ${error.message}`);
              console.error('Full error:', error);
            }