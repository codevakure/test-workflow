name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'
      - '**.js'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get the latest commit SHA from the PR
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;
            
            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a Set of existing comments to prevent duplicates
            const existingComments = new Set(
              comments.map(comment => `${comment.path}:${comment.line}:${comment.body}`)
            );

            // Get the latest PR changes
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a map of modified files and their content
            const fileContents = new Map();
            for (const file of files) {
              try {
                if (file.status === 'removed') {
                  fileContents.set(file.filename, { status: 'removed' });
                  continue;
                }

                const content = fs.readFileSync(file.filename, 'utf8');
                fileContents.set(file.filename, {
                  content,
                  lines: content.split('\n'),
                  status: file.status
                });
              } catch (error) {
                console.error(`Error reading file ${file.filename}: ${error}`);
                fileContents.set(file.filename, { status: 'removed' });
              }
            }

            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              const commentBody = `${priorityEmoji[priority]}**${category}**\n\n${message}`;
              const commentKey = `${file.filename}:${line}:${commentBody}`;
              
              if (!existingComments.has(commentKey)) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: file.filename,
                  body: commentBody,
                  line: line
                });
              }
            }

            async function checkTypeScriptFile(file, content, lines) {
              // Angular Component Checks
              if (content.includes('@Component')) {
                if (!content.includes('ChangeDetectionStrategy.OnPush')) {
                  await createComment(file, 1, 'recommended', 'Performance Optimization',
                    'Consider using ChangeDetectionStrategy.OnPush for better performance.'
                  );
                }

                // Check for standalone components
                if (content.includes('standalone: false') || !content.includes('standalone:')) {
                  await createComment(file, 1, 'recommended', 'Modern Angular Practices',
                    'Consider using standalone components for better tree-shaking and modularity.'
                  );
                }
              }

              // Observable Memory Leak Checks
              const subscribeLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => line.includes('subscribe'));
              
              const hasUnsubscribe = content.includes('unsubscribe()') || 
                                   content.includes('takeUntil') ||
                                   content.includes('| async');
              
              if (subscribeLines.length > 0 && !hasUnsubscribe) {
                for (const { index } of subscribeLines) {
                  await createComment(file, index, 'critical', 'Memory Leak Risk',
                    'Subscription not properly managed. Use takeUntil, async pipe, or manual unsubscription.'
                  );
                }
              }
            }

            async function checkHtmlFile(file, content, lines) {
              // Performance Checks
              const ngForLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => line.includes('*ngFor') && !line.includes('trackBy'));
              
              for (const { index } of ngForLines) {
                await createComment(file, index, 'critical', 'Performance',
                  'Add trackBy function to improve performance with *ngFor.'
                );
              }

              // Accessibility checks
              const accessibilityChecks = [
                {
                  pattern: /<img[^>]*(?!alt=)[^>]*>/,
                  message: 'IMG elements must have alt attributes'
                },
                {
                  pattern: /<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/,
                  message: 'BUTTON elements should have meaningful content'
                }
              ];

              for (const check of accessibilityChecks) {
                const matches = lines
                  .map((line, index) => ({ line, index: index + 1 }))
                  .filter(({ line }) => check.pattern.test(line));

                for (const { index } of matches) {
                  await createComment(file, index, 'critical', 'Accessibility',
                    check.message
                  );
                }
              }
            }

            async function checkStyleFile(file, content, lines) {
              const colorLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => /#[0-9a-fA-F]{3,6}/.test(line));

              for (const { index } of colorLines) {
                await createComment(file, index, 'optional', 'Style Management',
                  'Consider using CSS variables for better maintainability.'
                );
              }
            }

            async function checkFileContent(file, content, lines, extension) {
              // Security Checks
              if (content.includes('innerHTML') || content.includes('bypassSecurityTrust')) {
                const lineNum = lines.findIndex(line => 
                  line.includes('innerHTML') || line.includes('bypassSecurityTrust')
                ) + 1;
                if (lineNum > 0) {
                  await createComment(file, lineNum, 'critical', 'Security Risk',
                    'Potential XSS vulnerability detected. Use Angular\'s built-in sanitization.'
                  );
                }
              }

              // File type specific checks
              const checksMap = {
                ts: checkTypeScriptFile,
                html: checkHtmlFile,
                scss: checkStyleFile,
                css: checkStyleFile
              };

              if (checksMap[extension]) {
                await checksMap[extension](file, content, lines);
              }
            }

            // Process files
            const allowedExtensions = ['ts', 'html', 'scss', 'css', 'js'];
            
            for (const file of files) {
              const fileInfo = fileContents.get(file.filename);
              if (file.status !== 'removed' && fileInfo?.content) {
                const extension = file.filename.split('.').pop().toLowerCase();
                if (allowedExtensions.includes(extension)) {
                  await checkFileContent(file, fileInfo.content, fileInfo.lines, extension);
                }
              }
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;

            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Get the list of files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a map of file contents
            const fileContents = new Map();
            for (const file of files) {
              if (file.status !== 'removed') {
                try {
                  const content = fs.readFileSync(file.filename, 'utf8');
                  fileContents.set(file.filename, {
                    content,
                    lines: content.split('\n'),
                    status: file.status
                  });
                } catch (error) {
                  console.error(`Error reading file ${file.filename}: ${error}`);
                  fileContents.set(file.filename, { status: 'removed' });
                }
              } else {
                fileContents.set(file.filename, { status: 'removed' });
              }
            }

            async function verifyFix(comment) {
              const file = comment.path;
              const fileInfo = fileContents.get(file);
              
              if (!fileInfo || fileInfo.status === 'removed') {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - File has been removed.',
                  in_reply_to: comment.id
                });
                return true;
              }

              const { content, lines } = fileInfo;
              
              if (!lines[comment.line - 1] || 
                  lines[comment.line - 1] !== comment.original_line) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - Code has been modified.',
                  in_reply_to: comment.id
                });
                return true;
              }

              return false;
            }

            // Check remaining critical issues
            const criticalIssues = [];
            for (const comment of comments) {
              if (!comment.body.includes('âœ…') && 
                  comment.body.includes('ðŸš¨ CRITICAL')) {
                const isResolved = await verifyFix(comment);
                if (!isResolved) {
                  criticalIssues.push(comment);
                }
              }
            }

            if (criticalIssues.length > 0) {
              core.setFailed(`${criticalIssues.length} critical issues must be resolved before merging.`);
            }