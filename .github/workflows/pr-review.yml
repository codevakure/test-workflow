name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get the latest commit SHA from the PR
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;
            
            // Store existing comments to prevent duplicates
            const existingComments = new Map();
            const { data: currentComments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });
            
            for (const comment of currentComments) {
              const key = `${comment.path}:${comment.line}:${comment.body}`;
              existingComments.set(key, comment);
            }

            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              const commentBody = `${priorityEmoji[priority]}**${category}**\n\n${message}`;
              const commentKey = `${file.filename}:${line}:${commentBody}`;
              
              // Check if comment already exists
              if (!existingComments.has(commentKey)) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: file.filename,
                  body: commentBody,
                  line: line
                });
              }
            }

            async function checkFileContent(file, content, lines, fileExt) {
              // Security Checks
              if (content.includes('innerHTML') || content.includes('bypassSecurityTrust')) {
                const lineNum = lines.findIndex(line => 
                  line.includes('innerHTML') || line.includes('bypassSecurityTrust')
                ) + 1;
                if (lineNum > 0) {
                  await createComment(file, lineNum, 'critical', 'Security Risk',
                    'Potential XSS vulnerability detected. Use Angular\'s built-in sanitization.'
                  );
                }
              }

              // File type specific checks
              const checksMap = {
                ts: checkTypeScriptFile,
                html: checkHtmlFile,
                scss: checkStyleFile,
                css: checkStyleFile
              };

              if (checksMap[fileExt]) {
                await checksMap[fileExt](file, content, lines);
              }
            }

            async function checkTypeScriptFile(file, content, lines) {
              // Observable Memory Leak Checks
              const subscribeLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => line.includes('subscribe'));
              
              const hasUnsubscribe = content.includes('unsubscribe()') || 
                                   content.includes('takeUntil') ||
                                   content.includes('| async');
              
              if (subscribeLines.length > 0 && !hasUnsubscribe) {
                for (const { index } of subscribeLines) {
                  await createComment(file, index, 'critical', 'Memory Leak Risk',
                    'Subscription not properly managed. Use takeUntil, async pipe, or manual unsubscription.'
                  );
                }
              }

              // Additional TypeScript checks...
              // (Rest of the TypeScript checks remain the same)
            }

            async function checkHtmlFile(file, content, lines) {
              // Track existing issues to prevent duplicates
              const reportedIssues = new Set();

              // Performance Checks
              const ngForLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => line.includes('*ngFor') && !line.includes('trackBy'));
              
              for (const { index } of ngForLines) {
                const issueKey = `${file.filename}:${index}:ngFor`;
                if (!reportedIssues.has(issueKey)) {
                  await createComment(file, index, 'critical', 'Performance',
                    'Add trackBy function to improve performance with *ngFor.'
                  );
                  reportedIssues.add(issueKey);
                }
              }

              // Accessibility checks with line tracking
              const accessibilityChecks = [
                {
                  pattern: /<img[^>]*(?!alt=)[^>]*>/,
                  message: 'IMG elements must have alt attributes'
                },
                {
                  pattern: /<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/,
                  message: 'BUTTON elements should have meaningful content'
                },
                {
                  pattern: /<input[^>]*(?!aria-label|id=)[^>]*>/,
                  message: 'INPUT elements must have proper accessibility attributes'
                }
              ];

              for (const check of accessibilityChecks) {
                const matches = lines
                  .map((line, index) => ({ line, index: index + 1 }))
                  .filter(({ line }) => check.pattern.test(line));

                for (const { index } of matches) {
                  const issueKey = `${file.filename}:${index}:${check.message}`;
                  if (!reportedIssues.has(issueKey)) {
                    await createComment(file, index, 'critical', 'Accessibility',
                      check.message
                    );
                    reportedIssues.add(issueKey);
                  }
                }
              }
            }

            async function checkStyleFile(file, content, lines) {
              const colorLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => /#[0-9a-fA-F]{3,6}/.test(line));

              for (const { index } of colorLines) {
                await createComment(file, index, 'optional', 'Style Management',
                  'Consider using CSS variables for better maintainability.'
                );
              }
            }

            // Process changed files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            for (const file of files) {
              if (file.status !== 'removed') {  // Skip deleted files
                const content = fs.readFileSync(file.filename, 'utf8');
                const lines = content.split('\n');
                const fileExt = file.filename.split('.').pop();
                
                await checkFileContent(file, content, lines, fileExt);
              }
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            async function verifyFix(file, comment) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                const lines = content.split('\n');
                
                // Handle deleted files or lines
                if (!fs.existsSync(file) || comment.line > lines.length) {
                  return true; // Consider it resolved if file or line no longer exists
                }

                // Verification rules
                const rules = {
                  'Security Risk': () => !content.includes('innerHTML') && !content.includes('bypassSecurityTrust'),
                  'Performance': () => comment.body.includes('trackBy') ? content.includes('trackBy') : true,
                  'Accessibility': () => {
                    const line = lines[comment.line - 1] || '';
                    if (comment.body.includes('IMG')) return !/<img[^>]*(?!alt=)[^>]*>/.test(line);
                    if (comment.body.includes('BUTTON')) return !/<button[^>]*>(?!\s*[^<]*[^<\s])[^>]*<\/button>/.test(line);
                    if (comment.body.includes('INPUT')) return !/<input[^>]*(?!aria-label|id=)[^>]*>/.test(line);
                    return true;
                  },
                  'Memory Leak Risk': () => {
                    return content.includes('takeUntil') || 
                           content.includes('| async') ||
                           (content.includes('unsubscribe()') && content.includes('ngOnDestroy'));
                  },
                  'Style Management': () => {
                    const line = lines[comment.line - 1] || '';
                    return !/#[0-9a-fA-F]{3,6}/.test(line);
                  }
                };

                // Find matching rule and verify
                const category = Object.keys(rules).find(key => comment.body.includes(key));
                return category ? rules[category]() : false;
              } catch (error) {
                console.error(`Error verifying fix for ${file}: ${error}`);
                return false;
              }
            }

            // Process each comment
            for (const comment of comments) {
              try {
                if (comment.body.includes('âœ…')) continue; // Skip already resolved comments
                
                const isFixed = await verifyFix(comment.path, comment);
                
                if (isFixed) {
                  // Create resolution comment
                  await github.rest.pulls.createReviewComment({
                    ...context.repo,
                    pull_number: context.issue.number,
                    commit_id: latestCommitSha,
                    path: comment.path,
                    line: comment.line,
                    body: 'âœ… Issue resolved based on implemented changes.',
                    in_reply_to: comment.id
                  });
                }
              } catch (error) {
                console.error(`Error processing comment: ${error}`);
              }
            }

            // Check for remaining critical issues
            const criticalIssues = comments.filter(comment => 
              comment.body.includes('ðŸš¨ CRITICAL') && 
              !comment.body.includes('âœ…')
            );

            if (criticalIssues.length > 0) {
              core.setFailed('Critical issues must be resolved before merging.');
            }