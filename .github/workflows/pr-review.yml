name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'
      - '**.js'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get PR information
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;
            
            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a Set of existing comments
            const existingComments = new Set(
              comments.map(comment => `${comment.path}:${comment.line}:${comment.body}`)
            );

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              const commentBody = `${priorityEmoji[priority]}**${category}**\n\n${message}`;
              const commentKey = `${file.filename}:${line}:${commentBody}`;
              
              if (!existingComments.has(commentKey)) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: latestCommitSha,
                  path: file.filename,
                  body: commentBody,
                  line: line
                });
              }
            }

            async function checkTemplateStrings(file, content, lines) {
              // Extract all ngIf and ngSwitch string conditions
              const ngDirectiveRegex = /\[(ngIf|ngSwitch)\]=\"['"]([^'"]+)['"]\"/g;
              let match;
              const stringUsages = new Map();

              while ((match = ngDirectiveRegex.exec(content)) !== null) {
                const [, directive, value] = match;
                if (!stringUsages.has(value)) {
                  stringUsages.set(value, { count: 0, lines: [] });
                }
                const usage = stringUsages.get(value);
                usage.count++;
                usage.lines.push(lines.findIndex(line => line.includes(match[0])) + 1);
              }

              // Check for repeated strings that should be enums
              for (const [value, usage] of stringUsages) {
                if (usage.count >= 2) {
                  const enumName = value.split('-')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join('');

                  const message = `String literal '${value}' is used ${usage.count} times. Consider creating an enum:\n\n` +
                    `\`\`\`typescript\n` +
                    `export enum ${enumName}Type {\n` +
                    `  ${value.toUpperCase().replace(/-/g, '_')} = '${value}',\n` +
                    `  // Add other values here\n` +
                    `}\n\n` +
                    `// In your component:\n` +
                    `${enumName}Type = ${enumName}Type; // Add this to make enum available in template\n` +
                    `\`\`\`\n\n` +
                    `Then use it in your template:\n` +
                    `\`[ngIf]="someValue === ${enumName}Type.${value.toUpperCase().replace(/-/g, '_')}"\``;

                  await createComment(file, usage.lines[0], 'recommended', 'Template Type Safety',
                    message
                  );
                }
              }
            }

            async function checkTypeScriptFile(file, content, lines) {
              // Check for memory leaks in subscriptions
              const subscribeLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  // Only match actual subscribe calls, not comments or strings
                  const isComment = line.trim().startsWith('//') || line.trim().startsWith('/*');
                  const isActualSubscribe = /\.subscribe\s*\(/.test(line);
                  return !isComment && isActualSubscribe;
                });

              for (const { line, index } of subscribeLines) {
                // Check for proper subscription management in the component
                const relevantContent = content.split('\n')
                  .slice(Math.max(0, index - 10), index + 10)
                  .join('\n'); // Look at surrounding context

                const hasUnsubscribe = 
                  // Check for takeUntil pattern
                  /\.pipe\s*\(\s*takeUntil\s*\(/.test(relevantContent) ||
                  // Check for async pipe in corresponding template
                  /\|\s*async/.test(content) ||
                  // Check for proper unsubscribe in ngOnDestroy
                  /ngOnDestroy\s*\(\s*\)\s*{[^}]*this\.[^.]+\.unsubscribe\s*\(\s*\)/.test(content);
                
                if (!hasUnsubscribe) {
                  await createComment(file, index, 'critical', 'Memory Leak Risk',
                    `This subscription at ${file.filename}:${index} lacks proper cleanup.\n\n` +
                    `Memory leaks occur when subscriptions remain active after component destruction. You should:\n\n` +
                    `1. Use \`.pipe(takeUntil(this.destroy$))\` pattern:\n` +
                    `\`\`\`typescript\n` +
                    `private destroy$ = new Subject<void>();\n\n` +
                    `this.someService.getData().pipe(\n` +
                    `  takeUntil(this.destroy$)\n` +
                    `).subscribe(data => { ... });\n` +
                    `\`\`\`\n\n` +
                    `2. OR use the async pipe in template:\n` +
                    `\`\`\`html\n` +
                    `<div>{{ data$ | async }}</div>\n` +
                    `\`\`\`\n\n` +
                    `3. OR manually unsubscribe in ngOnDestroy:\n` +
                    `\`\`\`typescript\n` +
                    `ngOnDestroy() {\n` +
                    `  this.subscription.unsubscribe();\n` +
                    `}\n` +
                    `\`\`\``
                  );
                }
              }

              // Check for security vulnerabilities
              const securityLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  // Ignore comments
                  if (line.trim().startsWith('//') || line.trim().startsWith('/*')) return false;
                  
                  // Check for actual security-sensitive patterns
                  return (
                    /\binnerHTML\s*=/.test(line) || 
                    /bypassSecurityTrust\w+\s*\(/.test(line)
                  );
                });

              for (const { line, index } of securityLines) {
                const isInnerHTML = /\binnerHTML\s*=/.test(line);
                const message = isInnerHTML ?
                  `Direct innerHTML manipulation at ${file.filename}:${index} creates an XSS vulnerability.\n\n` +
                  `Cross-Site Scripting (XSS) can occur when untrusted HTML is rendered. Instead:\n\n` +
                  `1. For trusted HTML, use Angular's DomSanitizer:\n` +
                  `\`\`\`typescript\n` +
                  `constructor(private sanitizer: DomSanitizer) {}\n\n` +
                  `safeHtml = this.sanitizer.sanitize(SecurityContext.HTML, userHtml);\n` +
                  `\`\`\`\n\n` +
                  `2. For text content, use textContent or interpolation:\n` +
                  `\`\`\`typescript\n` +
                  `element.textContent = content; // DOM\n` +
                  `{{ content }} // Template\n` +
                  `\`\`\`` :
                  `Bypassing security sanitization at ${file.filename}:${index} is dangerous.\n\n` +
                  `Using bypassSecurityTrust* methods skips Angular's XSS protections. Instead:\n\n` +
                  `1. Use appropriate SecurityContext sanitization:\n` +
                  `\`\`\`typescript\n` +
                  `this.sanitizer.sanitize(SecurityContext.HTML, content);\n` +
                  `\`\`\`\n\n` +
                  `2. Or create a custom safe pipe for specific use cases:\n` +
                  `\`\`\`typescript\n` +
                  `@Pipe({ name: 'safeHtml' })\n` +
                  `export class SafeHtmlPipe {\n` +
                  `  transform(html: string): SafeHtml {\n` +
                  `    return this.sanitizer.sanitize(SecurityContext.HTML, html);\n` +
                  `  }\n` +
                  `}\n` +
                  `\`\`\``;
                
                await createComment(file, index, 'critical', 'Security Risk', message);
              }

              // Check for console.log statements
              const consoleLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => /console\.(log|debug|info)\(/.test(line));

              for (const { index } of consoleLines) {
                await createComment(file, index, 'recommended', 'Code Cleanliness',
                  'Remove console.log statement from production code.'
                );
              }

              // Check for empty methods
              const methodRegex = /(\w+\s*\([^)]*\)\s*{[^}]*})/g;
              const methods = content.match(methodRegex) || [];
              
              for (const method of methods) {
                const methodName = method.match(/(\w+)\s*\(/)[1];
                const methodContent = method.match(/{([^}]*)}/)[1].trim();
                
                if (methodName === 'constructor' && methodContent === '') {
                  continue;
                }
                
                const isEmptyMethod = !methodContent || methodContent.split('\n')
                  .every(line => line.trim() === '' || line.trim().startsWith('//'));
                
                if (isEmptyMethod) {
                  const lineNum = lines.findIndex(line => line.includes(methodName)) + 1;
                  await createComment(file, lineNum, 'recommended', 'Code Cleanliness',
                    `Remove empty method '${methodName}' if it's not being used. If it's meant to be implemented later, add a TODO comment explaining the intended functionality.`
                  );
                }
              }
            }

            async function checkHtmlFile(file, content, lines) {
              await checkTemplateStrings(file, content, lines);

              const ngForLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  const hasNgFor = line.includes('*ngFor');
                  const hasTrackBy = line.includes('trackBy');
                  const hasComplexBinding = (line.match(/{{.*}}/g) || []).length > 1;
                  return hasNgFor && !hasTrackBy && hasComplexBinding;
                });

              for (const { index } of ngForLines) {
                await createComment(file, index, 'recommended', 'Performance',
                  'Add trackBy function to improve rendering performance with complex *ngFor.'
                );
              }

              // Check accessibility issues
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.includes('<img') && !line.includes('alt=')) {
                  await createComment(file, i + 1, 'critical', 'Accessibility',
                    'Add alt attribute to image for screen reader support.'
                  );
                }
                if (line.includes('<button') && !line.includes('aria-label') && line.trim().endsWith('></button>')) {
                  await createComment(file, i + 1, 'critical', 'Accessibility',
                    'Empty button needs aria-label for screen reader support.'
                  );
                }
                if (line.includes('<input') && !line.includes('aria-label') && !line.includes('id=')) {
                  await createComment(file, i + 1, 'critical', 'Accessibility',
                    'Input needs an associated label or aria-label for accessibility.'
                  );
                }
              }
            }

            async function checkStyleFile(file, content, lines) {
              // Check for !important usage
              const importantLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  // Ignore comments
                  if (line.trim().startsWith('//') || line.trim().startsWith('/*')) return false;
                  if (line.includes('*/')) return false;
                  
                  // Match !important in actual CSS rules
                  return /:\s*[^;]+!\s*important\s*;/.test(line);
                });

              for (const { line, index } of importantLines) {
                await createComment(file, index, 'recommended', 'CSS Best Practices',
                  `\`!important\` declaration found in ${file.filename}:${index}.\n\n` +
                  `Using !important makes styles harder to maintain and override. Instead:\n\n` +
                  `1. Use more specific selectors:\n` +
                  `\`\`\`css\n` +
                  `.parent .specific-class { ... }\n` +
                  `\`\`\`\n\n` +
                  `2. Use combinators to increase specificity:\n` +
                  `\`\`\`css\n` +
                  `.sidebar > .nav-item { ... }\n` +
                  `\`\`\`\n\n` +
                  `3. If needed, use CSS custom properties for dynamic values:\n` +
                  `\`\`\`css\n` +
                  `:root { --primary-color: #007bff; }\n` +
                  `.element { color: var(--primary-color); }\n` +
                  `\`\`\``
                );
              }

              // Check for magic numbers
              const magicNumberLines = lines
                .map((line, index) => ({ line, index: index + 1 }))
                .filter(({ line }) => {
                  const hasPx = line.match(/\d+px/g);
                  const hasRem = line.match(/\d+rem/g);
                  const hasEm = line.match(/\d+em/g);
                  return (hasPx && hasPx.length > 0) || (hasRem && hasRem.length > 0) || (hasEm && hasEm.length > 0);
                });

              for (const { index, line } of magicNumberLines) {
                if (line.match(/(width|height|margin|padding):/)) {
                  await createComment(file, index, 'optional', 'Maintainability',
                    'Consider using CSS variables for consistent spacing values.'
                  );
                }
              }
            }

            // Process files
            for (const file of files) {
              try {
                if (file.status === 'removed') continue;
                
                const content = await fs.readFileSync(file.filename, 'utf8');
                const lines = content.split('\n');
                const extension = file.filename.split('.').pop().toLowerCase();

                switch (extension) {
                  case 'ts':
                    await checkTypeScriptFile(file, content, lines);
                    break;
                  case 'html':
                    await checkHtmlFile(file, content, lines);
                    break;
                  case 'scss':
                  case 'css':
                    await checkStyleFile(file, content, lines);
                    break;
                }
              } catch (error) {
                console.error(`Error processing file ${file.filename}:`, error);
              }
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Get PR information
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const headSha = pr.head.sha;

            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a map of file contents
            const fileContents = new Map();
            for (const file of files) {
              try {
                if (file.status === 'removed') {
                  fileContents.set(file.filename, { status: 'removed' });
                  continue;
                }

                const content = fs.readFileSync(file.filename, 'utf8');
                fileContents.set(file.filename, {
                  content,
                  lines: content.split('\n'),
                  status: file.status,
                  patch: file.patch
                });
              } catch (error) {
                console.error(`Error reading file ${file.filename}:`, error);
                fileContents.set(file.filename, { status: 'removed' });
              }
            }

            async function verifyFix(comment) {
              const file = comment.path;
              const fileInfo = fileContents.get(file);
              
              // Handle removed files
              if (!fileInfo || fileInfo.status === 'removed') {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: headSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - File has been removed.',
                  in_reply_to: comment.id
                });
                return true;
              }

              // Handle removed or changed lines
              if (comment.line > fileInfo.lines.length || 
                  (fileInfo.status === 'modified' && !fileInfo.lines[comment.line - 1]?.includes(comment.original_line))) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: headSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - Code has been modified or removed.',
                  in_reply_to: comment.id
                });
                return true;
              }

              // Check if comment has been resolved by reviewing the conversation
              // Handle manual resolutions by checking conversation
              const conversationResolved = comments.some(reply => 
                reply.in_reply_to === comment.id && 
                (/resolved|fixed|completed|done/i.test(reply.body) ||
                 reply.body.includes('âœ…') ||
                 reply.state === 'resolved')
              );
              
              if (conversationResolved) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: headSha,
                  path: comment.path,
                  line: comment.line,
                  body: 'âœ… Issue resolved - Manually marked as resolved.',
                  in_reply_to: comment.id
                });
                return true;
              }

              // Verification rules for specific issues
              const rules = {
                'Memory Leak Risk': () => {
                  return fileInfo.content.includes('takeUntil') || 
                         fileInfo.content.includes('| async') || 
                         fileInfo.content.includes('unsubscribe()');
                },
                'Security Risk': () => {
                  const line = fileInfo.lines[comment.line - 1] || '';
                  return !line.includes('innerHTML') && 
                         !line.includes('bypassSecurityTrust');
                },
                'Accessibility': () => {
                  const line = fileInfo.lines[comment.line - 1] || '';
                  if (line.includes('<img')) {
                    return line.includes('alt=');
                  }
                  if (line.includes('<button')) {
                    return line.includes('aria-label') || 
                           !line.trim().endsWith('></button>');
                  }
                  if (line.includes('<input')) {
                    return line.includes('aria-label') || 
                           line.includes('id=');
                  }
                  return false;
                },
                'Performance': () => {
                  if (comment.body.toLowerCase().includes('ngfor')) {
                    const line = fileInfo.lines[comment.line - 1] || '';
                    return line.includes('trackBy');
                  }
                  return false;
                },
                'Template Type Safety': () => {
                  const line = fileInfo.lines[comment.line - 1] || '';
                  return !line.includes("'") && !line.includes('"') && 
                         line.includes('Type.') && line.includes('enum');
                }
              };

              // Check if any rule matches and is satisfied
              const category = Object.keys(rules).find(key => 
                comment.body.includes(key)
              );
              
              if (category && rules[category]()) {
                await github.rest.pulls.createReviewComment({
                  ...context.repo,
                  pull_number: context.issue.number,
                  commit_id: headSha,
                  path: comment.path,
                  line: comment.line,
                  body: `âœ… Issue resolved - ${category} has been fixed.`,
                  in_reply_to: comment.id
                });
                return true;
              }

              return false;
            }

            // Clean up outdated comments
            // Group comments by their location (file:line)
            const commentsByLocation = new Map();
            for (const comment of comments) {
              const key = `${comment.path}:${comment.line}`;
              if (!commentsByLocation.has(key)) {
                commentsByLocation.set(key, []);
              }
              commentsByLocation.get(key).push(comment);
            }
            
            // Find and delete outdated comments
            for (const [location, locationComments] of commentsByLocation) {
              if (locationComments.length > 1) {
                // Sort by creation time, newest first
                locationComments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                // Delete all but the newest comment
                for (let i = 1; i < locationComments.length; i++) {
                  try {
                    await github.rest.pulls.deleteReviewComment({
                      ...context.repo,
                      comment_id: locationComments[i].id
                    });
                    core.info(`Deleted outdated comment: ${locationComments[i].id}`);
                  } catch (error) {
                    core.warning(`Failed to delete comment ${locationComments[i].id}: ${error.message}`);
                  }
                }
              }
            }

            // Process remaining comments
            for (const comment of comments) {
              try {
                // Skip if already has a resolution comment
                if (comments.some(reply => 
                  reply.in_reply_to === comment.id && 
                  reply.body.includes('âœ…')
                )) {
                  continue;
                }

                const isFixed = await verifyFix(comment);
                if (isFixed) {
                  core.info(`Resolved comment in ${comment.path} at line ${comment.line}`);
                }
              } catch (error) {
                console.error('Error processing comment:', error);
              }
            }

            // Re-fetch comments to get latest state including our new resolution comments
            const { data: updatedComments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Check for remaining unresolved critical issues
            let remainingCriticalIssues = updatedComments.filter(comment => {
              // Skip if not a critical issue
              if (!comment.body.includes('ðŸš¨ CRITICAL')) return false;

              // Check for various forms of resolution:
              // 1. Automated resolution (âœ…)
              // 2. Manual resolution keywords in replies
              // 3. Manual resolution keywords in original comment thread
              const isResolved = updatedComments.some(reply => {
                // Check if this is a reply to our comment
                const isReplyToComment = reply.in_reply_to === comment.id;
                
                if (!isReplyToComment) return false;

                // Check for various resolution indicators
                const hasCheckmark = reply.body.includes('âœ…');
                const hasResolutionKeyword = /resolved|fixed|completed|done/i.test(reply.body);
                const isMarkedResolved = reply.body.toLowerCase().includes('marked as resolved');
                const hasApprovalEmoji = /ðŸ‘|âœ…|â˜‘ï¸|âœ”ï¸/.test(reply.body);
                
                return hasCheckmark || hasResolutionKeyword || isMarkedResolved || hasApprovalEmoji;
              });

              // Also check if the original comment itself indicates resolution
              const originalCommentResolved = /resolved|fixed|completed|done/i.test(comment.body) ||
                                           comment.body.includes('marked as resolved');

              return !isResolved && !originalCommentResolved;
            });

            if (remainingCriticalIssues.length > 0) {
              core.info('Found unresolved critical issues:');
              remainingCriticalIssues.forEach(issue => {
                core.info(`- ${issue.path}:${issue.line} - ${issue.body.split('\n')[0]}`);
              });
              core.setFailed(`${remainingCriticalIssues.length} critical issues must be resolved before merging.`);
            } else {
              core.info('All critical issues have been resolved.');
            }