name: Ionic/Angular PR Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            async function createComment(github, context, file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              await github.rest.pulls.createReviewComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                commit_id: file.sha,
                path: file.filename,
                body: `${priorityEmoji[priority]}**${category}**\n\n${message}`,
                line: line
              });
            }

            async function checkFileContent(github, context, file, content, lines, fileExt) {
              // Security Checks
              if (content.includes('innerHTML') || content.includes('bypassSecurityTrust')) {
                await createComment(
                  github,
                  context,
                  file,
                  lines.findIndex(line => line.includes('innerHTML')) + 1,
                  'critical',
                  'Security Risk',
                  'Potential XSS vulnerability detected. Use Angular\'s built-in sanitization.'
                );
              }

              // TypeScript Specific Checks
              if (fileExt === 'ts') {
                await checkTypeScriptFile(github, context, file, content, lines);
              }

              // HTML Specific Checks
              if (fileExt === 'html') {
                await checkHtmlFile(github, context, file, content, lines);
              }

              // Style Specific Checks
              if (fileExt === 'scss' || fileExt === 'css') {
                await checkStyleFile(github, context, file, content, lines);
              }
            }

            async function checkTypeScriptFile(github, context, file, content, lines) {
              // Observable Memory Leak Checks
              const subscriptions = content.match(/subscribe\s*\(/g);
              const hasUnsubscribe = content.includes('unsubscribe()') || 
                                   content.includes('takeUntil') ||
                                   content.includes('| async');
              
              if (subscriptions && !hasUnsubscribe) {
                await createComment(
                  github,
                  context,
                  file,
                  lines.findIndex(line => line.includes('subscribe')) + 1,
                  'critical',
                  'Memory Leak Risk',
                  'Subscription not properly managed. Use one of these patterns:\n\n' +
                  '```typescript\n' +
                  '// Option 1: Using takeUntil\n' +
                  'private destroy$ = new Subject<void>();\n\n' +
                  'ngOnInit() {\n' +
                  '  this.someObservable$.pipe(\n' +
                  '    takeUntil(this.destroy$)\n' +
                  '  ).subscribe(data => ...);\n' +
                  '}\n\n' +
                  'ngOnDestroy() {\n' +
                  '  this.destroy$.next();\n' +
                  '  this.destroy$.complete();\n' +
                  '}\n\n' +
                  '// Option 2: Using async pipe in template\n' +
                  '{{ data$ | async }}\n\n' +
                  '// Option 3: Manual unsubscription\n' +
                  'private subscription: Subscription;\n\n' +
                  'ngOnInit() {\n' +
                  '  this.subscription = this.data$.subscribe(...);\n' +
                  '}\n\n' +
                  'ngOnDestroy() {\n' +
                  '  this.subscription?.unsubscribe();\n' +
                  '}\n' +
                  '```'
                );
              }

              // Rest of the TypeScript checks remain the same, just update the createComment calls
              // ... (rest of the checks)
            }

            async function checkHtmlFile(github, context, file, content, lines) {
              // Performance Checks
              if (content.includes('*ngFor') && !content.includes('trackBy')) {
                await createComment(
                  github,
                  context,
                  file,
                  lines.findIndex(line => line.includes('*ngFor')) + 1,
                  'critical',
                  'Performance',
                  'Add trackBy function to improve performance with *ngFor.'
                );
              }

              // Rest of the HTML checks remain the same, just update the createComment calls
              // ... (rest of the checks)
            }

            async function checkStyleFile(github, context, file, content, lines) {
              const hardcodedColors = content.match(/#[0-9a-fA-F]{3,6}/g);
              if (hardcodedColors) {
                await createComment(
                  github,
                  context,
                  file,
                  lines.findIndex(line => line.includes(hardcodedColors[0])) + 1,
                  'optional',
                  'Style Management',
                  'Consider using CSS variables for better maintainability.'
                );
              }
            }

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            for (const file of files) {
              const content = fs.readFileSync(file.filename, 'utf8');
              const lines = content.split('\n');
              const fileExt = file.filename.split('.').pop();
              
              await checkFileContent(github, context, file, content, lines, fileExt);
            }

      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const { data: comments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            async function verifyFix(file, comment) {
              const content = fs.readFileSync(file, 'utf8');
              
              // Verification rules remain the same
              // ... (rest of the verification logic)
            }

            for (const comment of comments) {
              try {
                const isFixed = await verifyFix(comment.path, comment);
                
                if (isFixed) {
                  await github.rest.pulls.deleteReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                  
                  await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.payload.pull_request.number,
                    commit_id: comment.commit_id,
                    path: comment.path,
                    line: comment.line,
                    body: 'âœ… Issue resolved automatically based on implemented changes.'
                  });
                }
              } catch (error) {
                console.error(`Error processing comment: ${error}`);
              }
            }
            
            const remainingCriticalIssues = comments.filter(async comment => 
              comment.body.includes('ðŸš¨ CRITICAL') && 
              !(await verifyFix(comment.path, comment))
            );

            if (remainingCriticalIssues.length > 0) {
              core.setFailed('Critical issues must be resolved before merging.');
            }