name: Ionic/Angular PR Review v12

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.ts'
      - '**.html'
      - '**.scss'
      - '**.css'
      - '**.js'

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Code Quality Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get PR information
            const { data: pr } = await github.rest.pulls.get({
              ...context.repo,
              pull_number: context.issue.number,
            });
            const latestCommitSha = pr.head.sha;
            console.log('PR SHA:', latestCommitSha);

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              ...context.repo,
              pull_number: context.issue.number,
            });
            console.log('Number of files:', files.length);

            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              ...context.repo,
              pull_number: context.issue.number,
            });

            // Create a Set of existing comments
            const existingComments = new Set(
              comments.map(comment => `${comment.path}:${comment.line}:${comment.body}`)
            );

            async function createComment(file, line, priority, category, message) {
              const priorityEmoji = {
                critical: 'ðŸš¨ CRITICAL: ',
                recommended: 'ðŸ’¡ RECOMMENDED: ',
                optional: 'ðŸ’­ OPTIONAL: '
              };
              
              const commentBody = `${priorityEmoji[priority]}**${category}**\n\n${message}`;
              const commentKey = `${file.filename}:${line}:${commentBody}`;
              
              if (!existingComments.has(commentKey)) {
                try {
                  await github.rest.pulls.createReviewComment({
                    ...context.repo,
                    pull_number: context.issue.number,
                    commit_id: latestCommitSha,
                    path: file.filename,
                    body: commentBody,
                    line: line,
                    side: 'RIGHT'
                  });
                  console.log('Created comment for', file.filename, 'at line', line);
                } catch (error) {
                  console.error('Failed to create comment:', error);
                }
              }
            }

            for (const file of files) {
              try {
                if (file.status === 'removed') continue;

                // Check if file is HTML and has changes
                if (!file.filename.endsWith('.html') || !file.patch) {
                  continue;
                }

                console.log('Processing file:', file.filename);
                
                // Use the patch from the PR instead of reading the file
                const lines = file.patch.split('\n')
                  .filter(line => line.startsWith('+'))
                  .map(line => line.substring(1));
                
                console.log('Processing lines:', lines.length);

                const stringLiteralsMap = new Map();

                lines.forEach((line, index) => {
                  if (line.includes('*ngIf')) {
                    console.log('Found ngIf line:', line);
                    // Match string literals in ngIf directives
                    const matches = line.match(/[=!]=?\s*['"]([^'"]+)['"]/g);
                    if (matches) {
                      matches.forEach(match => {
                        const literalMatch = match.match(/['"]([^'"]+)['"]/);
                        if (literalMatch) {
                          const value = literalMatch[1];
                          if (!stringLiteralsMap.has(value)) {
                            stringLiteralsMap.set(value, []);
                          }
                          // Use the actual line number from the PR diff
                          const lineNumber = file.patch.split('\n')
                            .findIndex(l => l.includes(line)) + 1;
                          stringLiteralsMap.get(value).push(lineNumber);
                          console.log('Found literal:', value, 'at line:', lineNumber);
                        }
                      });
                    }
                  }
                });

                console.log('String literals found:', Array.from(stringLiteralsMap.entries()));

                for (const [literal, lineNumbers] of stringLiteralsMap.entries()) {
                  if (lineNumbers.length >= 2) {
                    console.log('Found repeated literal:', literal, 'at lines:', lineNumbers);
                    const enumName = literal.includes('-') ? 
                      literal.split('-')[0].toUpperCase() : 
                      literal.toUpperCase();

                    await createComment(
                      file,
                      lineNumbers[0],
                      'recommended',
                      'String Literal Optimization',
                      `String literal '${literal}' is used ${lineNumbers.length} times in Angular directives.\n\n` +
                      `To improve type safety and maintainability, create an enum:\n\n` +
                      `\`\`\`typescript\nenum ${enumName}Status {\n` +
                      `  ${literal.toUpperCase().replace(/-/g, '_')} = '${literal}',\n` +
                      `  // Add other related status values here\n` +
                      `}\n\`\`\`\n\n` +
                      `Then update the template to use:\n` +
                      `\`\`\`html\n*ngIf="variable === ${enumName}Status.${literal.toUpperCase().replace(/-/g, '_')}"\n\`\`\`\n\n` +
                      `Found on lines: ${lineNumbers.join(', ')}`
                    );
                  }
                }

              } catch (error) {
                console.error(`Error processing file ${file.filename}:`, error);
              }
            }
            
      - name: Verify Changes and Auto-resolve Comments
        if: github.event.action == 'synchronize' || github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              console.log('Starting verification and cleanup of comments...');
              
              const { data: comments } = await github.rest.pulls.listReviewComments({
                ...context.repo,
                pull_number: context.issue.number
              });

              const resolvedCommentIds = new Set();
              const deletedCommentIds = new Set();

              function isCommentResolved(comment) {
                const bodyLower = comment.body.toLowerCase();
                
                console.log(`Checking comment in ${comment.path}:${comment.line}`);
                console.log('Comment body:', bodyLower);
                
                const resolutionIndicators = [
                  'resolved',
                  'fixed',
                  'âœ…',
                  'completed',
                  'done',
                  'show resolved',
                  'has been resolved',
                  'resolve conversation',
                  'marked as resolved'
                ];

                if (comment.position === null) {
                  console.log('Comment is outdated/resolved due to position being null');
                  return true;
                }

                for (const indicator of resolutionIndicators) {
                  if (bodyLower.includes(indicator)) {
                    console.log(`Found resolution indicator: ${indicator}`);
                    return true;
                  }
                }

                const conversation = [
                  comment,
                  ...comments.filter(reply => reply.in_reply_to === comment.id)
                ];

                return conversation.some(c => {
                  const replyLower = c.body.toLowerCase();
                  return resolutionIndicators.some(indicator => {
                    const found = replyLower.includes(indicator);
                    if (found) {
                      console.log(`Found resolution indicator in reply: ${indicator}`);
                    }
                    return found;
                  });
                });
              }

              for (const comment of comments) {
                if (comment.user.login !== 'github-actions[bot]') continue;

                if (isCommentResolved(comment)) {
                  resolvedCommentIds.add(comment.id);
                  
                  if (!deletedCommentIds.has(comment.id)) {
                    try {
                      await github.rest.pulls.deleteReviewComment({
                        ...context.repo,
                        comment_id: comment.id
                      });
                      deletedCommentIds.add(comment.id);
                      console.log(`Deleted resolved comment: ${comment.path}:${comment.line}`);
                    } catch (error) {
                      console.warn(`Failed to delete comment ${comment.id}:`, error.message);
                    }
                  }
                }
              }

              const { data: remainingComments } = await github.rest.pulls.listReviewComments({
                ...context.repo,
                pull_number: context.issue.number
              });

              const criticalIssues = remainingComments.filter(comment => 
                comment.user.login === 'github-actions[bot]' &&
                comment.body.includes('ðŸš¨ CRITICAL') &&
                !resolvedCommentIds.has(comment.id) &&
                !deletedCommentIds.has(comment.id)
              );

              if (criticalIssues.length > 0) {
                core.info('Found remaining critical issues:');
                criticalIssues.forEach(issue => {
                  core.info(`- ${issue.path}:${issue.line} - ${issue.body.split('\n')[0]}`);
                });
                core.setFailed(`${criticalIssues.length} critical issues must be resolved before merging.`);
              } else {
                core.info('All critical issues have been resolved.');
              }
            } catch (error) {
              console.error('Full error:', error);
              core.setFailed(`Error in verification step: ${error.message}`);
            }